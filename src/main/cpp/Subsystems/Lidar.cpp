// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


// Cargo Finding Constants
#define CARGO_RADIUS						152.4		// the cross-sectional radius of the cargo 9" off the ground
#define CARGO_MAX_ACCEPTED_ERROR			10			// 
#define CARGO_MAX_ACCEPTED_DELTA_ANGLE		1.75		// if the difference in angle between points is greater than this -> start a new group
#define CARGO_MAX_ACCEPTED_DELTA_DISTANCE	50			// if the difference in distance between lidar readings is greater than this -> start new group
#define CARGO_MIN_ACCEPTED_SIDE_PORTION		0.5			// groups are dismissed as not being cargo if this angle is not found in from one side of the group to the other
#define CARGO_MIN_ACCPETED_TOTAL_PORTION	1.5 		// groups are dismissed as not being cargo if this angle is not found in the group on either side of the group's base point
#define CARGO_SCAN_LEFT_LIMIT				120			// the cargo finding algorithm doesn't look at points more than this many degrees to the left (from directly forwards)
#define CARGO_SCAN_RIGHT_LIMIT				120			// the cargo finding algorithm doesn't look at points more than this many degrees to the right (from directly forwards)
#define CARGO_SCAN_MAX_DISTANCE				1500		// the cargo finding algorithm doesn't look at points closer that this distance (mm)
#define CARGO_SCAN_MIN_DISTANCE				50			// the cargo finding algorithm doesn't look at points beyond this distance (mm)
#define WAIST_DISTANCE						183			// distance between waist and lidar

// Rocket Hatch Finding COnstants
#define MAX_ACCPETED_ROCKET_FIN_LENGTH		745			// educated guess, needs testing
#define MIN_ACCPETED_ROCKET_FIN_LEGNTH		700			// same
#define ROCKET_SIDE_CENTRE_OFFSET			234.95		// the distance between the edge of the rocket side and the centre of the rocket side

#define _USE_MATH_DEFINES // this is supposed to help math constants (pi) work better

#include <ctime>
#include <math.h>
#include <iostream>
//#include <fstream>
#include "../../include/Subsystems/Lidar.h"
#include "../../include/Subsystems/LidarViewer.h"
#include "../../include/Robot.h"
#include "frc/SerialPort.h"
//#include "../RobotMap.h"



// this function is passed into std::sort() to allow it to sort the groups bassed on .closestPointDistance
static bool  sortCompareGroups(grouptp group1, grouptp group2) {
	return group1.basePointDistance < group2.basePointDistance;
}


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Lidar::Lidar() : frc::Subsystem("Lidar") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONSt
	printf("Lidar Initialization!\n");
	glob_lidar_exists = 1; // when 0, don't try to get lidar data.
	//SerialPort serport = frc::SerialPort(115200);
	if (glob_lidar_exists)
		{
		serport = new frc::SerialPort(115200,frc::SerialPort::Port::kUSB,8,frc::SerialPort::Parity::kParity_None,frc::SerialPort::StopBits::kStopBits_One); // Set up serial port.
		//printf("serport=%X\n\r",serport);
		serport->SetWriteBufferMode(frc::SerialPort::kFlushOnAccess);
		serport->SetFlowControl(frc::SerialPort::FlowControl::kFlowControl_None);
		serport->SetWriteBufferSize(128); // Don't need a lot of space for writing.
		serport->SetReadBufferSize(1024); // allow up to 1024 characters to be stored for reading.
		serport->Flush(); // Clear out any old data.
		}
	samplecount = 0;
	cstate = 0;
	txseq = 0;
	prevangle = -1; // prevangle is not valid yet.
	tocnt = 0; // Time out counter, 10 seconds of readings and we stop everything.
	chcnt = 100;
	glob_lidar_ready = 0;
	cubeFindCase = 0;
	cubeSquaringCase = 0;
	cubeIntakeCase = 0;
	glob_lidar_may_run = 0;
	doneGo = false;
	prevtstamp = (int)(frc::Timer::GetFPGATimestamp()*1000000); // get value in microseconds.

}

void Lidar::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Lidar::Periodic() {
	// Put code here to be run every loop
	int x,ch;
	time_t t=time(0);
	struct tm *now;

	if (logfile.is_open())
		{
		//sprintf(buf,"E,%d,%d,%f,%f\n",Robot::driveTrain->getLeftEncoder()->Get(),Robot::driveTrain->getRightEncoder()->Get(),Robot::ahrs->GetAngle(),Timer::GetFPGATimestamp());
		//logfile.write(buf,strlen(buf));
		}
	if (txcmd != 0)
		{
		switch(txcmd)
			{
			case 1: // transmit data to get information packet from lidar
				//printf("Sending Info request string to serial port\n");
				serport->Write("\xA5\x5A\x14\x00\x00\x00\x04",7);
				//printf("Write(\\xA5\\x5A\\x14\\x00\\x00\\x00\\x04)\n");
				//printf("Get Info Requested A5 5A 14 00 00 00 04\n");
				txcmd = 0; // indicate this request has been sent.
				cstate=0;
				break;
			case 2: // stop - send to halt data being transmitted from lidar
				serport->Write("\xA5\x25",2);
				//printf("Stop A5 25 sent.\n");
				txcmd = 0;
				cstate = 0;
				break;
			case 3: // Reset - perform a reboot of the lidar system
				// Make sure we wait 2ms (1/500 sec) before sending another command.
				// should be no problem given that we'll only transmit at 50hz
				serport->Write("\xA5\x40",2);
				//printf("RESET A5 40");
				txcmd = 0;
				cstate = 0;
				break;
			case 4: // Express Scan.  There are other options but we're only implementing this one.
				serport->Write("\xA5\x82\x05\x00\x00\x00\x00\x00\x22",9);
				//printf("Express Scan Initiated\n");
				txcmd = 0;
				cstate = 0;
				break;
			case 5: // With USB interface board, we should be able to control motor speed 0 to 1023, default 660
				// Will need checksum calculation for this,  Start with 0 and ^= all bytes, including 0xA5 Sync
				//printf("Sending motor PWM command 0xF0\n");
				//serport->Write("\xA5\xF0\x02\x94\x02\xC1",6); // See if this will start the motor.
				//serport->Write("\xA5\xFF\x04\x00\x00\x00\x80\xDE",8); // Get flag to see if board supports PWM command.
				//serport->Write("\xA5\xFF",2);
				serport->Write("\xA5\xF0\x02",3);
				chksum = 0xA5^0xF0^0x02;
				serport->Write((char *)&pwmspeed,2);
				chksum ^= (pwmspeed & 0xFF);
				chksum ^= ((pwmspeed >> 8) & 0xFF); // calculate checksum.
				serport->Write((char *)&chksum,1);
				//printf("Write(\\A5\\F0\\02\\%02X\\%02X\\%02X)\n",pwmspeed&0xFF,pwmspeed>>8,chksum);
				txcmd = 0;
				break;
			case 6: // Get Health
				//printf("Sending Get Health 0x52\n",cstate);
				serport->Write("\xA5\x52",2);
				txcmd = 0;
				cstate = 0;
				break;
			case 7: // Send A5 50
				serport->Write("\xA5\x50");
				//printf("Write(\\xA5\\x50)");
				txcmd = 0;
				cstate = 0;
				break;
			case 8: // Send A5 59
				serport->Write("\xA5\x59");
				//printf("Write(\\xA5\\x59)");
				txcmd = 0;
				cstate = 0;
				break;
			}
		}
	loopcount = 0; // serport->Read() does not always read all available bytes.  Sometimes, we only get a few
	// loopcount will allow this routine to loop up to 25 times in order to try to get all the bytes
	if (glob_lidar_exists)
		{
		bytes_available = serport->GetBytesReceived();
		tim1 = frc::Timer::GetFPGATimestamp(); // See how much time this takes.
		while((loopcount < 25)&&(bytes_available > 0))
			{
			loopcount++;
			if (bytes_available > 1024)
				bytes_to_read = 1024;
			else
				bytes_to_read = bytes_available;
			if (bytes_to_read > 0)
				{
				//printf("bytes_to_read=%d\n",bytes_to_read);
				rdcnt = serport->Read(rxbuf,bytes_to_read);
				for(x = 0;x<rdcnt;x++) // process each character in the serial port buffer.
					{
					ch = *(rxbuf+x); // get the character
					// printf("ch=%02x, cstate=%d, dcnt=%d\n",ch,cstate,dcnt);
					//if (cstate < 4)
					//if (chcnt < 16)
					//	{
					//	printf("%02X ",ch);
					//	chcnt++;
					//	}
					switch(cstate)
						{
						case 0: // expecting a packet start character
							if (ch == 0xA5)
								cstate++; // go to next state if we get a valid packet start character
							break;
						case 1: // Expecting char 2 of the response descriptor
							if (ch == 0x5A)
								{
								cstate++; // valid character, advance to next state
								bcnt = 0; // need to count 4 bytes in next case
								rdat = 0; // place result in rdat
								}
							else
								cstate=0; // not what we expected, back to state 0
							break;
						case 2: // 30 bits of response length.  Get all 32 and then split it.
							rdat |= (((unsigned int)(ch)) << (bcnt * 8)); // get data, LSB first.
							bcnt++;
							if (bcnt == 4)
								{
								sendmode = rdat >> 30; // get the 2 bits of send mode. 0=single response, 1=multiple response.
								nbytes = rdat & 0x3FFFFFFF; // strip to upper 2 bit from rdat and that's our data length.
								printf("\nExpecting %d data bytes\n",nbytes);
								if (nbytes < 100)
									cstate++;
								else
									cstate = 0; // error in length, back to state 0
								}
							break;
						case 3: // expecting data type
							dtype = ch; // 0x82 for Express Packet, 0x04 for response to get_info
							dcnt = 0; // prepare to count payload data bytes (counts to nbytes)
							cstate++;
							break;
						case 4: // expecting payload data of nbytes (can be up to 84 bytes for express scan mode)
							// will be considerably less when we get the info data block.
							if (dcnt < 128)
								payload[dcnt] = ch; // store the data as long as it doesn't exceed the buffer
							dcnt++;
							if (dcnt >= nbytes)
								{
								// payload is complete.  process the data
								//printf("Got a complete payload, dtype=%d bytes_to_read=%d, actually read=%d, available=%d\n",dtype,bytes_to_read,rdcnt,bytes_available);
								chcnt=0; // Show any characters we get on rs232 port, starting now
								if (dtype == 0x18) // This is info, get some of it
									{
									model = payload[0];
									firmware1 = payload[1];
									firmware2 = payload[2];
									hardware = payload[3];
									serial = (payload[4])+((unsigned int)payload[5]<<8)+((unsigned int)payload[5]<<16)+((unsigned int)payload[5]<<24);
									// we'll ignore the other serial numbers for now.
									printf("Lidar model:%d\n",model);
									printf("Lidar firmware %d.%d\n",firmware2,firmware1);
									printf("Lidar hardware %d\n",hardware);
									printf("Lidar serial number %d\n",serial);
									//txcmd = 6; // go check health
									cstate = 0;
									}
								else if (dtype == 0x06)
									{
									printf("Health = %02X\n",payload[0]);
									printf("Error Code=%02X%02X\n",payload[2],payload[1]);
									//txcmd = 5; // Try to start motor now.
									cstate = 0;
									}
								else if (dtype == 0x82) // This is the express scan data.  Time to sort out all the data bits and pieces
									{
									// First 4 bytes - sync1, 2, checksum, start angle, S indicator.
									synchbyte = (payload[0] & 0xF0) + ((payload[1] >> 4) & 0x0F); // This must be 0xA5
									if (synchbyte == 0xA5)
										{
										stangle = payload[2] + ((payload[3] & 0x7F) << 8); // actual start angle value.

										chksum = (payload[0] & 0x0F) + ((payload[1] << 4) & 0xF0); // 8 bit checksum
										//printf("stangle=%6.2f, chksum=%02X\n",(double)stangle/64.0,chksum);

										//int xx = 0;
										//for(acnt = 0;acnt < 0x82;acnt++)
										//	{
										//	printf("%02X ",payload[acnt]);
										//	xx ^= payload[acnt];
										//	}
										//printf("\nxx=%02X\nstangle=%d,prevangle=%d\n",xx & 0xFF,stangle,prevangle);

										tstamp = (int)(frc::Timer::GetFPGATimestamp()*1000000); // get value in microseconds.
										// Don't worry about FPGATimestamp roll over.  It's 72 minutes
										// Possible mess up if running robot for a long time during program testing.

										// if we have a valid prevangle, update the cabdat[] from last express data set
										// with the correct angles and then add the cabdat[] to the full scan array and
										// then we can re-use cabdat[] to store data from this payload.
										if (prevangle != -1)
											{
											for(acnt=0;acnt<32;acnt++) // Do all 32 angles from last set of cabins
												{ // place actual angle values in previous cabin[] array.
												if (stangle >= prevangle)
													cabdat[acnt].angle = prevangle + (stangle - prevangle) * acnt / 32 + cabdat[acnt].angle;
												else
													cabdat[acnt].angle = prevangle + (23040 + stangle - prevangle) * acnt / 32 + cabdat[acnt].angle;
												//if (cabdat[acnt].angle >= 23040)
												//	cabdat[acnt].angle -= 23040; // Correct for angles above 360 deg
												tmpdat[samplecount].dist = cabdat[acnt].dist;
												tmpdat[samplecount].angle = cabdat[acnt].angle;
												tmpdat[samplecount].tstamp = prevtstamp + (tstamp - prevtstamp) * acnt / 32; // record correct time-stamp values.
												if (samplecount < 1023)
													samplecount++;
												}
											}

										prevtstamp = tstamp;
										//printf("\nstangle=%d,%10.2f\n",stangle,(double)stangle/64.0);

										sss = payload[3] >> 7; // This is indicator of new scan (1 for first data set of a scan.)
										// if sss is 1, that means we have compiled a complete array of readings.
										// this is a good time to copy them to the array to be used by the main lidar
										// processing routines and then set the indicator to tell the forground
										// that data is ready.
										if ((sss == 1)||(stangle < prevangle)) // sss doesn't seem to work, just use cross over in angle value.
											{
											for(acnt = 0;acnt < samplecount;acnt++) // copy entire array.
												{
												lidat[acnt].angle = tmpdat[acnt].angle - (6 * 64);
												lidat[acnt].dist = tmpdat[acnt].dist;
												lidat[acnt].tstamp = tmpdat[acnt].tstamp;
												//printf("%d,%d,%d\n",lidat[acnt].angle,lidat[acnt].dist,lidat[acnt].tstamp);
												if ((lidat[acnt].angle > 90*64)&&(lidat[acnt].angle < 270*64)&&(lidat[acnt].dist != 0))
													{
													if (logfile.is_open())
														{
														sprintf(buf,"D,%d,%d,%d\n",lidat[acnt].angle,lidat[acnt].dist,lidat[acnt].tstamp);
														logfile.write(buf,strlen(buf));
														}

													}
												}
											glob_lidar_ready = 1; // main processing routine can set this to 0 so
											// it can detect when the next valid lidar scan is ready for processing.
											glob_lidar_count = samplecount;
											samplecount = 0; // begin storing new data.
											skcnt=0; // Keep rebooter sleeping, data is coming in.
											}

										prevangle = stangle; // update prevangle to equal this angle for next data set.

										for(cabins = 0;cabins < 16;cabins++)
											{ // process the 16 cabins
											caboff = 4+cabins * 5; // offset to data start for this cabin
											dist1 = (payload[caboff] >> 2) + ((int)payload[caboff+1] << 6); // distance value
											// Documentation on angle data is not correct.  [caboff] may be msbit, may be lsbits.  Not sure.
											// going with the assumption that they're bits 4 and 5 and that [caboff + 4] is bits 0-3
											// Note that these are signed 6 bit values. 0b11111 = -1, 0x10000 = -16.
											// May need to have a look at the value to make sure we have the bits figured out correctly.
											//
											delta1 = ((payload[caboff+1] & 0x03) << 4) + (payload[caboff+4] & 0x0F); // 5 bits of angle delta
											if (delta1 >= 32)
												delta1-=64; // these are negative values 0b11111 (31) is actually -1.
											dist2 = (payload[caboff + 2] >> 2) + ((int)payload[caboff+3] << 6); // distance value
											delta2 = ((payload[caboff+3] & 0x03) << 4) + ((payload[caboff+4] & 0xF0) >> 4); // 5 bits of angle delta
											if (delta2 >= 32)
												delta2-=64;
											// have distance and delta angle.  These delta's are corrections to the
											// angle that would be calculated using direct interpolation between the stangle of this
											// set of 32 readings and the stangle of the next 32 readings. By doing (stangle[1] - stangle[2]) / 32
											// The trick is we need stangle[2] before we can calculate the angles for data of stangle[1]
											// with confident accurace.  Since angles between 270 and 90 won't matter to us, this is not a big deal.
											// When preparing the data set, it will be necessary to go back and update the previous 32
											// angles based on the stangle value of the new packet.
											cabdat[cabins<<1].dist = dist1;
											cabdat[cabins<<1].angle = delta1; // storing delta1 for now, will update with actual angle next reading.
											cabdat[(cabins<<1)+1].dist = dist2;
											cabdat[(cabins<<1)+1].angle = delta2;
											}
										dcnt = 0; // expect another 0x82 bytes, stay in this state.
										}
									else // Synch byte failed to be 0xA5.  Data is no longer aligned.
										{ // Stop the transfer and then re-initated it
										txcmd = 2; // This will send the scan stop request.
										txseq = 5; // Go to state 5 which will stop current scan and start another one.
										}
									}
								// cstate = 0; // Back to cstate 0 when we've received all the bytes we expected.
								} // if(dcnt >= nbytes)
							break;
						} // switch(cstate)
					} // (for x < bytes_to_read)
				} // if there were bytes to read.
			// if ((bytes_to_read == 0)&&(txcmd == 0)) // If there's nothing to read, consider a sequence of commands to try to get scanner going.
			bytes_available = serport->GetBytesReceived();
			}
		if (txcmd == 0)
			{ // We really don't need to do a lot.  Just tell it to go, now that we have the speed thing figured out.
			// We can modify this part to start the scan and monitor for problems.  If we stop getting data, this part of the code
			// can reset the system and re-start.
			//printf("txseq=%d\n",txseq);
			switch(txseq)
				{
				case 0:// Start up the motor as the first thing we do.
					if (glob_lidar_may_run != 0) // Wait for signal from main program loop to tell lidar to run.
						{
						txcmd = 5; // start up the motor
						pwmspeed = 660;
						// txcmd = 0;
						skcnt = 0; // use this to delay for a 100 count (2 seconds) to allow lidar to spin up.
						if (!logfile.is_open())
							{
							now = localtime(&t);
							sprintf(buf,"/media/sda1/LL%02d%02d%02d%02d%02d%02d.txt",now->tm_year,now->tm_mon,now->tm_mday,now->tm_hour,now->tm_min,now->tm_sec);
							logfile.open(buf,std::ios::out | std::ios::binary);
							}
						else
							{
							now = localtime(&t);
							sprintf(buf,"/media/sdb1/LL%02d%02d%02d%02d%02d%02d.txt",now->tm_year,now->tm_mon,now->tm_mday,now->tm_hour,now->tm_min,now->tm_sec);
							logfile.open(buf,std::ios::out | std::ios::binary);
							}
						txseq++;
						}
					break;
				case 1: // after the 2 second delay, start the scan and look for data.
					skcnt++;
					if (skcnt >= 100)
						{
						serport->Flush(); // Clear data from serial port.
						cstate = 0; // begin at state 0 to obtain valid packets.
						txcmd = 1;
						txseq++;
						}
					break;
				case 2: // Redundant motor start up.
					txcmd = 5; // start up the motor
					pwmspeed = 660;
					txseq++;
					break;
				case 3:
					txcmd = 4; // Begin scanning in express mode.
					skcnt = 0; // next state will increase this.  It gets cleared when we receive valid scan data.
					txseq++;
					break;
				case 4:
					skcnt++;  // if this gets to 200, it's been 4 seconds since we got data. Restart the scanner.
					if (skcnt >= 500)
						txseq = 5; // restart.
					if (glob_lidar_may_run == 0)
						txseq = 7; // stop everything, lidar may shut down.
					//tocnt++;
					//if (tocnt >= 50)
					//	 glob_lidar_may_run = 0;
					break;
				case 5:
					txcmd = 2; // Send a stop to stop the express scanning.
					printf("\nLidar scan restarted!!\n");
					txseq++;
					break;
				case 6:
					txseq=3; // Back to txseq=3 which will start another express scan.
					break;
				case 7:
					txcmd = 2;
					txseq++;
					break;
				case 8:
					pwmspeed = 0; // stop the motor.
					txcmd = 5; // Motor speed to 0
					txseq++;
					break;
				case 9:
					if (glob_lidar_may_run == 0)
						{
						if (logfile.is_open())
							logfile.close();
						txseq = 0; // back to state 0 once lidar has been shut down.
						// Intialize all the variables that will allow another lidar sequence to begin.
						samplecount = 0;
						cstate = 0;
						txseq = 0;
						prevangle = -1; // prevangle is not valid yet.
						tocnt = 0; // Time out counter, 10 seconds of readings and we stop everything.
						}
					break;
				}
			}
		}
	tim2 = frc::Timer::GetFPGATimestamp(); // See how much time this takes.
	//printf("Time in Lidar::Periodic = %12.9f, loopcount=%d\n",tim2 - tim1,loopcount);
	} // proc_serial()

void Lidar::startLidar()
	{
	glob_lidar_may_run = 1;
	}

void Lidar::stopLidar()
	{
	glob_lidar_may_run = 0;
	}

void Lidar::readLidar()
	{
	glob_lidar_ready = 0;
	}

bool Lidar::readComplete()
	{
	if(glob_lidar_ready)
		LidarViewer::Get()->setPoints(glob_lidar_count,lidat);
	return glob_lidar_ready;
	}

void Lidar::convertToXY()
	{
	int j = 0;
	for(int i=0;i<glob_lidar_count;i++)
		{
		if(!lidat[i].dist)
			continue;
		double rad = M_PI * ((double)lidat[i].angle / 64.0) / 180;
		lidatXY[j].x = -((((double)lidat[i].dist) * std::sin(rad)));
		lidatXY[j].y = -((((double)lidat[i].dist) * std::cos(rad)));
		//printf(" %i,%i",lidatXY[j].x,lidatXY[j].y);
		j++;
		}
	printf("\n");
	xyCount = j;
	}

void Lidar::filterData(bool convertXY, double leftLimit, double rightLimit, int minDistance, int maxDistance) {

	unsigned int startidx = 0, n=0;
	double angle;
	//TODO: remove this line
	//convertToXY();
	for (int i = 0; i < glob_lidar_count; i++) {

		//Angle
		angle = ((double)lidat[i].angle / 64.0);
		//*** KLUGE ***
		// if leftLimit and rightLimit == 119, then adjust the angle to correct for finding rocket target.
		if ((leftLimit == 119.0)&&(rightLimit == 119.0))
			angle += 7.0; // Should be 3.5 degrees.  Using 8 to make sure we got the direction right.

		if (angle < (180 - leftLimit))
			continue;
		if (angle > (180 + rightLimit))
			continue;

		//Distance
		if ((lidat[i].dist < minDistance) || (lidat[i].dist > maxDistance))
			continue;

		lidFiltered[n].angle = angle;
		lidFiltered[n].dist = lidat[i].dist;
		lidFiltered[n].tstamp = lidat[i].tstamp;

		if (convertXY) {
			double rad = M_PI * (lidat[i].angle / 64.0) / 180;
			lidatXY[n].x = -(std::round((lidat[i].dist) * std::sin(rad)));
			lidatXY[n].y = -(std::round((lidat[i].dist) * std::cos(rad)));
			}

		n++;
		}

	if (convertXY)
		xyCount = n;

	filteredCount = n;

	//TODO: Delete this debug code:
	//printf("Cont: %i\n",xyCount);
	//for(int i = 0; i<xyCount; i++)
	//	printf(" %i,%i",lidatXY[i].x,lidatXY[i].y);
	//printf("\n");
	}


void Lidar::FindLines(){
	//Find lines
	double distX, distY, totalDist, angle, angle2, diff;
	bool newline; //used for determine outliers and whether or not to create a new line
	int n, m, NumLines = 0;
	int skipto = 0;
	int stpntsX[3], stpntsY[3]; // Place to keep 3 line starting points (for slope calc and compare)
	int stcnt; // Count 0..2 for number of start points we have acquired.
	int ndpntsX[3], ndpntsY[3]; // Place to keep 3 line ending points (for slope calc and compare)
	int ndcnt; // Count 0..2 for number of end points we have acquired
	int lidatcnt; // Keep count of how many lidar points are used by this line.  Need at least 12 to do the endpoint thing for slope comparison.
	double slope1,slope2,slope3,diff12,diff23,diff13;
	//Loop through the data
	for(n = 0; n < xyCount; n++)
		{
		//Allows the code to skip over data points that are determine to
		//	be outliers
		if(skipto != 0)
			{
			if(n < skipto)
				continue; //Skip this point until n == skipto
			skipto = 0;//reset the skip value
			}
		//To start thing the code sets the first line to start and end
		//	at point 0
		if(n == 0)
			{
			//set start position
			lines[0].start.x = lidatXY[n].x;
			lines[0].start.y = lidatXY[n].y;
			lines[0].lidarAnglest = lidFiltered[n].angle;
			lines[0].lidarDistst = lidFiltered[n].dist;
			lines[0].length = 0; // Can be used to verify if this is a legit line or not.

			stcnt = 0; // new line, 0 starting points.
			stpntsX[stcnt] = lidatXY[n].x; // stpnts get put into [0], then [1], then [2], no shifting.
			stpntsY[stcnt] = lidatXY[n].y;
			stcnt++; // We have 1 starting point.
			//set end position
			lines[0].end.x = lidatXY[n].x;
			lines[0].end.y = lidatXY[n].y;
			lines[0].lidarAnglend = lidFiltered[n].angle;
			lines[0].lidarDistnd = lidFiltered[n].dist;
			ndpntsX[2] = lidatXY[n].x; // ndpnts get put into [2] and are shifted down for each new point added.
			ndpntsY[2] = lidatXY[n].y;
			ndcnt = 1; // We have 1 ending point.
			lidatcnt = 1; // This line currently consists of 1 point.
			//Set current line to 0
			NumLines = 0;
			continue; //Go to next point
			}

		//Calculate the differences between this point and the end of the
		//	current line
		distX = (lidatXY[n].x - lines[NumLines].end.x);
		distY = (lidatXY[n].y - lines[NumLines].end.y);
		//Total distance between this point and the end of the current line
		totalDist = sqrt(pow(distX,2)+pow(distY,2));

		//Angle calculation using inverse sin of the rise divided by the hypotenuse
		//	Then its converted from radians into degrees
		angle = (180 * (asin(distY / totalDist))) / M_PI;

		//Checks if there is a valid angle to compare
		//	If both start and end points are the same then there is no valid angle
		//	and the code must add the point to the line.
		if((lines[NumLines].start.x == lines[NumLines].end.x)&&(lines[NumLines].start.y == lines[NumLines].end.y))
			{
			//Check if this point is within range
			//	If it is too far away then reset this line and continue
			if(totalDist > MAXDISTNEWLINE)
				{
				//Set start position
				lines[NumLines].start.x = lidatXY[n].x;
				lines[NumLines].start.y = lidatXY[n].y;
				lines[NumLines].lidarAnglest = lidFiltered[n].angle;
				lines[NumLines].lidarDistst = lidFiltered[n].dist;
				lines[NumLines].length = 0; // Can be used to verify if this is a legit line or not.

				stcnt = 0; // new line, 0 starting points.
				stpntsX[stcnt] = lidatXY[n].x; // stpnts get put into [0], then [1], then [2], no shifting.
				stpntsY[stcnt] = lidatXY[n].y;
				stcnt++; // We have 1 starting point.
				//Set end position
				lines[NumLines].end.x = lidatXY[n].x;
				lines[NumLines].end.y = lidatXY[n].y;
				lines[NumLines].lidarAnglend = lidFiltered[n].angle;
				lines[NumLines].lidarDistnd = lidFiltered[n].dist;

				ndpntsX[2] = lidatXY[n].x; // ndpnts get put into [2] and are shifted down for each new point added.
				ndpntsY[2] = lidatXY[n].y;
				ndcnt = 1; // We have 1 ending point.
				lidatcnt = 1; // This line currently consists of 1 point.
				continue;
				}
			//This point is in range, set the end point equal to it
			if (stcnt < 3) // If this is one of the 3 start points, add it to the list
				{
				stpntsX[stcnt] = lidatXY[n].x;	
				stpntsY[stcnt] = lidatXY[n].y;	
				stcnt++;
				}
			lines[NumLines].end.x = lidatXY[n].x;
			lines[NumLines].end.y = lidatXY[n].y;
			lines[NumLines].lidarAnglend = lidFiltered[n].angle;
			lines[NumLines].lidarDistnd = lidFiltered[n].dist;
			// Shift end point list to keep the last 2, then add this one to the end
			ndpntsX[0] = ndpntsX[1];
			ndpntsY[0] = ndpntsY[1];
			ndpntsX[1] = ndpntsX[2];
			ndpntsY[1] = ndpntsY[2];
			ndpntsX[2] = lidatXY[n].x; // Save this new end point 
			ndpntsY[2] = lidatXY[n].y;
			lidatcnt++; // Increase the points in this line.

			//Set the angle between this point and the line's end point
			//	as the line's new direction
			lines[NumLines].length = totalDist;
			lines[NumLines].angle = angle;
			continue;//Go to the next point
			}

		//Check if this point is suitable as a new end point of the current line
		//	The code checks of the angle and distance are with the range defined
		//	by the constants at the top.
		//		If angle is greater than the current line angle plus high range
		//		If angle is less than the current line angle minus low range
		//		if distance is greater than the max distance
		//			Then check if this is an outlier or the beginning of a new line
		if(((angle > (lines[NumLines].angle + MAXANGLERANGE))||(angle < (lines[NumLines].angle - MINANGLERANGE)))||(totalDist > MAXDISTRANGE))
			{
			//New line check: assume true
			newline = true;
			//To determine if this point is an outlier the next few points
			//	must be checked, if one of them is in line with the current
			//	line then this current point must be and outlier
			for(m=n+1;m<(OUTLIERCHECK + n + 1);m++)
				{
				if(m >= xyCount)
					{
					newline = false;
					break;
					}
				//Calculate the differences between this point and the end of the
				//	current line
				distX = (lidatXY[m].x - lines[NumLines].end.x);
				distY = (lidatXY[m].y - lines[NumLines].end.y);
				totalDist = sqrt(pow(distX,2)+pow(distY,2));
				//Angle calculation
				angle2 = (180 * (asin(distY / totalDist))) / M_PI;

				//Check if this point is in range
				if(((angle2 < (lines[NumLines].angle + MAXANGLERANGE))&&(angle2 > (lines[NumLines].angle - MINANGLERANGE)))&&(totalDist < MAXDISTRANGE))
					{
					//At this point the point is in range
					newline = false;//Do not create a new line, continue with current one
					skipto = m;//Skip the outliers
					break;//Exit this for loop back into the main one
					}
				}
			//Check if a new line needs to be made
			if (newline)
				{
				// Before we increment the NumLines, if we have lidatcnt >= 12, check the 3 start and end points to see
				// If the slope is good for at least 2 of the 3.  if the slope is off for the first start point or the last end
				// point, change the end point to make the line more accurate.
				if (lidatcnt >= 12) // Need at least 12 points for this to be valid.
					{ // Analysis of the 3 different line slopes to see if we should be ignoring 1 for a more-accurate angle.
					if (ndpntsX[2] - stpntsX[0] != 0)
						slope1 = (double)(ndpntsY[2] - stpntsY[0]) / (double)(ndpntsX[2] - stpntsX[0]);
					else slope1 = 0;
					if (ndpntsX[1] - stpntsX[1] != 0)
						slope2 = (double)(ndpntsY[1] - stpntsY[1]) / (double)(ndpntsX[1] - stpntsX[1]);
					else slope2 = 0;
					if (ndpntsX[0] - stpntsX[2] != 0)
						slope3 = (double)(ndpntsY[0] - stpntsY[2]) / (double)(ndpntsX[0] - stpntsX[2]);
					else slope3 = 0;
					diff12 = fabs(slope1 - slope2); // These should all be fairly small values
					diff23 = fabs(slope2 - slope3); // if 1 is larger and 2 are small, we have 
					diff13 = fabs(slope1 - slope3); // a condition where one should be ignored.
					//printf("Line (%d,%d) - (%d,%d) slopes %f, %f, %f, diffs %f, %f, %f\n",stpntsX[0],stpntsY[0],ndpntsX[2],ndpntsY[2],slope1,slope2,slope3,diff12,diff23,diff13);
					}

				//increment the line count
				NumLines++;
				//Check that the limit hasn't been reached
				if (NumLines == 100)
					break;
				//Set start position for the new line
				lines[NumLines].start.x = lidatXY[n].x;
				lines[NumLines].start.y = lidatXY[n].y;
				lines[NumLines].lidarAnglest = lidFiltered[n].angle;
				lines[NumLines].lidarDistst = lidFiltered[n].dist;
				lines[NumLines].length = 0; // Can be used to verify if this is a legit line or not.

				//Set end position for the new line
				lines[NumLines].end.x = lidatXY[n].x;
				lines[NumLines].end.y = lidatXY[n].y;
				lines[NumLines].lidarAnglend = lidFiltered[n].angle;
				lines[NumLines].lidarDistnd = lidFiltered[n].dist;


				stcnt = 0; // new line, 0 starting points.
				stpntsX[stcnt] = lidatXY[n].x; // stpnts get put into [0], then [1], then [2], no shifting.
				stpntsY[stcnt] = lidatXY[n].y;
				stcnt++; // We have 1 starting point.
				//Set end position
				ndpntsX[2] = lidatXY[n].x; // ndpnts get put into [2] and are shifted down for each new point added.
				ndpntsY[2] = lidatXY[n].y;
				ndcnt = 1; // We have 1 ending point.
				lidatcnt = 1; // This line currently consists of 1 point.

				}
			continue;//Go to next point
			}

		//If this code is reached then this point must be in range
		//	set it as the new end point for the current line
		if (stcnt < 3) // If this is one of the 3 start points, add it to the list
			{
			stpntsX[stcnt] = lidatXY[n].x;	
			stpntsY[stcnt] = lidatXY[n].y;	
			stcnt++;
			}
		lines[NumLines].end.x = lidatXY[n].x;
		lines[NumLines].end.y = lidatXY[n].y;
		lines[NumLines].lidarAnglend = lidFiltered[n].angle;
		lines[NumLines].lidarDistnd = lidFiltered[n].dist;

		// Shift end point list to keep the last 2, then add this one to the end
		ndpntsX[0] = ndpntsX[1];
		ndpntsY[0] = ndpntsY[1];
		ndpntsX[1] = ndpntsX[2];
		ndpntsY[1] = ndpntsY[2];
		ndpntsX[2] = lidatXY[n].x; // Save this new end point 
		ndpntsY[2] = lidatXY[n].y;
		lidatcnt++; // Increase the points in this line.

		//The actual direction of this line changes and must be recalculated
		distX = (lines[NumLines].end.x - lines[NumLines].start.x);
		distY = (lines[NumLines].end.y - lines[NumLines].start.y);
		totalDist = sqrt(pow(distX,2)+pow(distY,2));

		lines[NumLines].length = totalDist;
		lines[NumLines].angle = (180 * (asin(distY / totalDist))) / M_PI;
		}
	//NumLines++;
	linecnt = NumLines; // This will be NumLines+1, Only if final point in lidatXY is actually the end point of a line (rather unlikely)

	LidarViewer::Get()->setLines(linecnt,lines);

	//TODO: Remove this debug stuff!
	
	for(int i = 0; i<(linecnt+1); i++){
		//printf("Line %i: start(%i, %i) end(%i, %i) angle=%f length=%i \n",i, lines[i].start.x,lines[i].start.y, lines[i].end.x,lines[i].end.y,lines[i].angle,lines[i].length);
		if(logfile.is_open())
		{
			sprintf(buf,"L,%i,%i,%i,%i,%f,%i\n",lines[i].start.x,lines[i].start.y, lines[i].end.x,lines[i].end.y,lines[i].angle,lines[i].length);
			logfile.write(buf,strlen(buf));
		}
	} 

}

void Lidar::checkLinesForCubes(double frangle, double toangle){
	int n = 0, prev = 0;
	double diffWidth, diffHieght, angle, dist, distX, distY;
	tpPoint center;
	for(int i = 0; i<(linecnt+1); i++){
		if(prev == 1){
			//Check how far this line is from the prev cube
			distX = (lines[i].start.x - lines[i-1].end.x);
			distY = (lines[i].start.y - lines[i-1].end.y);
			dist = sqrt(pow(distX,2)+pow(distY,2));
			//If too close skip it
			if (dist < MAXDISTRANGE){
				prev = 0;
				continue;
			}
		}
		diffWidth = std::abs(CUBEWIDTH - lines[i].length);
		diffHieght = std::abs(CUBEHIEGHT - lines[i].length);
		if (((lines[i].length > 200)&&(lines[i].length < 360))&&(lines[i].angle > frangle)&&(lines[i].angle < toangle)){
			cubes[n].location.x = (lines[i].start.x + lines[i].end.x) / 2;
			cubes[n].location.y = (lines[i].start.y + lines[i].end.y) / 2;
			//Distance from 0,0 (lidar)
			cubes[n].distance = sqrt(pow(cubes[n].location.x,2) + pow(cubes[n].location.y,2));
			//Angle from the front from 0,0 (lidar)
			cubes[n].angle = (180 * (asin((double)(cubes[n].location.x) / (double)(cubes[n].distance)))) / M_PI;
			// prev = 1; // Commented out by Maurice 18-Mar-2018.  Caused process to miss first cube.
			n++;
		}
	}
	cubecnt = n;
	for(int i = 0; i<cubecnt; i++)
		{
		if(logfile.is_open())
			{
			sprintf(buf,"C,%i,%i,%i,%f\n",cubes[i].location.x,cubes[i].location.y, cubes[i].distance,cubes[i].angle);
			logfile.write(buf,strlen(buf));
			}
		//printf("Cube %i: Loca(%i, %i) dist=%i angle=%f\n",i, cubes[i].location.x,cubes[i].location.y, cubes[i].distance,cubes[i].angle);
		}
}

void Lidar::calculatePathToNearestCube()
	{
	double angle2use;
	if (cubecnt == 0) {
		rightcm = 0;
		leftcm = 0;
		doneGo = true;
		return;
	}
	printf("Cubes: %i\n",cubecnt);
	unsigned int idx = 0;
	int shortestdist = 6000;
	for (int i = 0; i < cubecnt; i++){
		if(cubes[i].distance < shortestdist){
			shortestdist = cubes[i].distance;
			idx = i;
		}
	}

	double theta = 0, r = 0, rLeft = 0, rRight = 0;
	angle2use = cubes[idx].angle + 3.0; // Shift for angle adjustment issues
	theta = (M_PI * angle2use)/180;
	theta = std::abs(theta);
	r = (cubes[idx].distance * std::sin((M_PI/2) - theta))/(std::sin(2 * theta));
	rRight = ((angle2use > 0) ? (r - 298) : (r + 298));
	rLeft = ((angle2use > 0) ? (r + 298) : (r - 298));
	rightcm = (theta * rRight)/5;
	leftcm = (theta * rLeft)/5;

//	//Bring it back a little
//	rightcm -= 3;
//	leftcm -= 3;

	// Found wasn't grabbing a cube so add a little bit
	if (isSwitchAuto) {
		rightcm -= 20;
		leftcm -= 20;
	} else {
		rightcm -= 11;
		leftcm -= 11;
	}

	printf("theta = %f, r = %f, rRight = %f, rLeft = %f\n", theta, r, rRight, rLeft);
	printf("rightcm = %i   leftcm = %i\n", rightcm, leftcm);
	}

// Put methods for controlling this subsystem
// here. Call these from Commands.

////////////////////////////////////////////////////////////// BALL FINDING //////////////////////////////////////////////////////////////////////

// this function is the accessor point for finding cargo
polarPoint Lidar::findCargo() {

	// this is William's filter function, it fills lidFiltered[] with data
	filterData(false, CARGO_SCAN_LEFT_LIMIT, CARGO_SCAN_RIGHT_LIMIT, CARGO_SCAN_MIN_DISTANCE, CARGO_SCAN_MAX_DISTANCE);

	// this function sorts through lidFiltered[] and divides the points into groups, storing the info in lidGroups[]
	groupPoints();

	// these are debug statements, they print out the point out the contents of lidFiltered[] and lidGroups[]
	//for (int i = 0; i < filteredCount; i++) printf("%f, %i\n", lidFiltered[i].angle, lidFiltered[i].dist);
	// for (int i = 0; i < groupCount; i++) printf("%i, %i, %f, %i, %i\n", lidGroups[i].startIndex, lidGroups[i].endIndex, lidGroups[i].basePointAngle, lidGroups[i].basePointDistance, lidGroups[i].scoreStartIndex);

	// this loop iterates through lidGroups[] and tests if each one is a cargo
	for ( int i = 0; i < groupCount; i++ ) {

		// if the group passes the isPotentialCargo() and the scoreGroup() test
		if (isPotentialCargo(&lidGroups[i]) && scoreGroup(&lidGroups[i]) < CARGO_MAX_ACCEPTED_ERROR) {

			// findCargoCentre iterates through the points in the chosen circle and calculates the centre
			findCargoCenter(lidGroups[i].basePointDistance);

			// Brad M: do the following calculations up in the GotoBall code in case we want to reuse for a future robot

//			// stores the cargo centre's angle and distance in variables with shorter names (because Andrew is OCD about how long his lines of code are ~ Hannah)
//			double lidarDist = (double)cargoCentrePoint.dist;
//			double lidAngle = (double)cargoCentrePoint.angle;
//			
//			// calculate the distance from the waist to the ball (using cosine law)
//			cargoCentrePoint.dist = sqrt(lidarDist*lidarDist + WAIST_DISTANCE*WAIST_DISTANCE -2 * lidarDist * WAIST_DISTANCE * cos(lidAngle * M_PI / 180.0));
//
//			// calculate the angle from the waist to the ball (using sine law)
//			cargoCentrePoint.angle = asin(lidarDist * sin(lidAngle * M_PI / 180.0) / cargoCentrePoint.dist) / M_PI * 180.0 - 180;

			// set the timestamp of the cargo centre to the current time stamp
			cargoCentrePoint.tstamp = (int)(frc::Timer::GetFPGATimestamp() * 1000000.0);

			return cargoCentrePoint;
		}
	}

	// if no acceptable circle is found return an zeroed polarPoint objec (with a time stamp)
	polarPoint noCargo;
	noCargo.angle = 0.0;
	noCargo.dist = 0;
	noCargo.tstamp = (int)(frc::Timer::GetFPGATimestamp() * 1000000.0);
	return noCargo;
}

// the function separates the lidar points into an array of groups
void Lidar::groupPoints() {

	// reset function from previous run
	groupCount = 0;

	// initialize first group
	lidGroups[0].startIndex = 0;							// set the start index of the cargo
	lidGroups[0].basePointDistance = lidFiltered[0].dist;	// sets the shortest distance in the group (sets it to the distance of lidFiltered[0] because that is currently the only point in the group)
	lidGroups[0].basePointAngle = lidFiltered[0].angle;		// sets the angle to the closest point in the group (sets it to the angle of lidFiltered[0] because that is currently the closest point in the group)
	lidGroups[0].scoreStartIndex = 0;						// sets the entry point for scoreGroup() (0 because there is currently only lidFiltered[0] in the group)
	equidistantPointCount = 1;								// sets the number of points that are tied for closest in the group (sets it to 1 because only one point is currently the closest)

	int p; // this variable needs ot be accessible after the for loop

	for (p = 1; p < filteredCount; p++ ) {

		// precompile conditions
		bool deltaAngleTooLarge = (lidFiltered[p].angle - lidFiltered[p - 1].angle) > CARGO_MAX_ACCEPTED_DELTA_ANGLE;
		bool deltaDistanceTooLarge = std::abs(lidFiltered[p].dist - lidFiltered[p - 1].dist) > CARGO_MAX_ACCEPTED_DELTA_DISTANCE;

		// if the difference in angle or distance is to large create a new group
		if (deltaAngleTooLarge || deltaDistanceTooLarge) {

			// finalize values for old group
			lidGroups[groupCount].endIndex = p - 1;									// set the group end index
			lidGroups[groupCount].basePointAngle /= (double)equidistantPointCount;	// average the basePointAngle (until now this was storing the sum of the angles of all the points that are tied for closest)
			groupCount++;															// increment groupCount

			// initialize new group
			equidistantPointCount = 1;												// resent equidistantPointCount
			lidGroups[groupCount].startIndex = p;									// set the new group's start index
			lidGroups[groupCount].basePointDistance = lidFiltered[p].dist;			// set the current basePointDistance
			lidGroups[groupCount].basePointAngle = lidFiltered[p].angle;			// set the current basePointAngle
			lidGroups[groupCount].scoreStartIndex = p;								// set the current entry point index for scoreGroup()
		}

		// if the current point the closest in the group
		else if (lidFiltered[p].dist < lidGroups[groupCount].basePointDistance) {
			
			equidistantPointCount = 1;										// reset the equidistantPointCount
			lidGroups[groupCount].basePointDistance = lidFiltered[p].dist;	// update the group's basePointDistance (to the distance that is currently the shortest)
			lidGroups[groupCount].basePointAngle = lidFiltered[p].angle;	// update the basePointAngle (to the angle of the point that is currently the closeset)
			lidGroups[groupCount].scoreStartIndex = p;						// reset the entry point index for scoreGroup()
		}

		// if the current reaiding is the same distance as the previous one
		else if ( lidFiltered[p].dist == lidGroups[groupCount].basePointDistance) {

			lidGroups[groupCount].basePointAngle += lidFiltered[p].angle;	// add to the basePointAngle, this gets averaged out when the group is finalized
			equidistantPointCount++;										// increment the equidistancePointCount (one more point is tied for closeset in the group)
		}
	}

	// finilize values for the last group
	lidGroups[groupCount].endIndex = p - 1;									// set the group end index
	lidGroups[groupCount].basePointAngle /= (double)equidistantPointCount;	// average the basePointAngle
	groupCount++;

	// sort the groups by proximity
	std::sort(lidGroups, lidGroups+groupCount, sortCompareGroups);
}

// this function checks if the input group is possibly cargo based on the angle that the group spans
bool Lidar::isPotentialCargo(grouptp *testGroup) {

	double angleBeforeCentrePoint = testGroup->basePointAngle - lidFiltered[testGroup->startIndex].angle;			// stores the angle between the smallest angle in the group and the group's basePointAngle
	double angleAfterCentrePoint = lidFiltered[testGroup->endIndex].angle - testGroup->basePointAngle;				// stores the angle between the largest angle in the group and the group's basePointAngle
	double totalAngleOnCargo = lidFiltered[testGroup->endIndex].angle - lidFiltered[testGroup->startIndex].angle;	// stores the angle between the start of teh group and the end of the group
	double minAngle = angleOnCargo(testGroup->basePointDistance);													// stores half the expected angle from the centre of the cargo to the edge
	double minAnglePerSide = minAngle * CARGO_MIN_ACCEPTED_SIDE_PORTION;		// the group is determined to not be a cargo if there is less than this angle on each side of the group's basePoint
	double minTotalAngle = minAngle * CARGO_MIN_ACCPETED_TOTAL_PORTION;			// the group is determined to not be a cargo if there is less than this angle in total on the cargo

	//printf("an before: %f, a after: %f, min a per side: %f, total a: %f, min total a: %f\n", angleBeforeCentrePoint, angleAfterCentrePoint, minAnglePerSide, totalAngleOnCargo, minTotalAngle);

	if (angleBeforeCentrePoint > minAnglePerSide && angleAfterCentrePoint > minAnglePerSide && totalAngleOnCargo > minTotalAngle)
		return true;
	else
		return false;
}

// this function returns the number of points expected to be visible on the cargo, based on the distance to the closest point
double Lidar::angleOnCargo(int distance) {
	return asin(CARGO_RADIUS/((double)distance + CARGO_RADIUS)) * 180.0/M_PI;
}

// this function iterates through points on a possible cargo and scores it based how close the readings are to the expected values
double Lidar::scoreGroup(grouptp *testGroup) {

	// reset the function from the previous run
	double cargoError = 0.0;	// stores the error of the group
	int pointCount = 0;			// stores the number of points found to be in the gorup

	// function variable declarations
	int i;						// this variable must be assesible after the loops
	double deltaAngle;			// stores the difference in angle between the current point and the group's basePointAngle
	double distanceExpected;	// stores the difference in distance between the current point and the group's basePointDistance

	// starting from the the group's scoreStartIndex, this loop iterates through lidFiltered backwards
	// until it finds it reaches the end of the group or it finds a point that does not mathematicaly fit on the cargo
	for (i = testGroup->scoreStartIndex; i >= testGroup->startIndex; i--) {

		deltaAngle = testGroup->basePointAngle - lidFiltered[i].angle;								// set deltaAngle
		distanceExpected = expectedDistance(deltaAngle, (double)testGroup->basePointDistance);		// set distanceExpected

		// if the the angle of the point is found to be off the edge of the cargo distanceExpected is set to -1.0
		if (distanceExpected == -1.0) {
			break;
		} else {
			cargoError += (double)lidFiltered[i].dist - distanceExpected;		// increases the cargoError by the difference between the expected distance and the distance measured by the lidar
			pointCount++;														// incrementents the point count (one more point was found to be on the potential cargo)
		}
	}
	cargoStartIndex = i + 1;		// set the cargoStartIndex to the first index that was found to be on the cargo

	// starting from one after the the group's scoreStartIndex, this loop iterates through lidFiltered forwards
	// until it finds it reaches the end of the group or it finds a point that does not mathematicaly fit on the cargo
	for (i = testGroup->scoreStartIndex + 1; i <= testGroup->endIndex; i++) {

		deltaAngle = testGroup->basePointAngle - lidFiltered[i].angle;
		distanceExpected = expectedDistance(deltaAngle, (double)testGroup->basePointDistance);

		if (distanceExpected == -1.0) {
			break;
		} else {
			cargoError += (double)lidFiltered[i].dist - distanceExpected;
			pointCount++;
		}
	}
	cargoEndIndex = i - 1;			// set the cargoStartIndex to the last index that was found to be on the cargo

	//printf("start index: %i, end index: %i, error: %f\n", cargoStartIndex, cargoEndIndex, (cargoError/pointCount));

	return std::abs(cargoError/pointCount); 	// average cargoError by dividing by the number of points found on the cargo and return the value
}

// this function conducts the math to calculate the expected distance to the ball based on the angle of the lidar reading
double Lidar::expectedDistance(double deltaAngle, double distance) {

	distance += CARGO_RADIUS;	// increase the input distance by the cargo radius (this distance is used as the distace to the centre of the cargo)

	double twoCosTheta = 2.0 * distance * cos(deltaAngle*M_PI/180.0);	// this value is used multiple times so it is precaclulated to avoid running cos() twice

	double discriminant = (twoCosTheta*twoCosTheta - 4.0 * (distance*distance - CARGO_RADIUS*CARGO_RADIUS));	// the discriminant is calculated to determine of the point is on the cargo

	// if the discriminant is negative the point is not mathematically on the cargo and there is no answer and the function returns -1.0
	if (discriminant < 0.0)
		return -1.0;

	// otherwise the expected distance to the point on the cargo (based on the angle between the reading and the centre of the cargo) is returned
	else
		return (twoCosTheta - sqrt(discriminant)) / 2;

}

// this function takes a cargo group as input and averages the point between the cargoStartIndex and cargoEndIndex in order to find the centre of the cargo
void Lidar::findCargoCenter(int basePointDistance) {

	// reset variables from previous run
	double cargoAngle = 0.0;		// stores the sum of the angles of all the points on the cargo

	// this loops sums the the angles of all the points on the cargo
	for (int i = cargoStartIndex; i <= cargoEndIndex; i++) {	
		cargoAngle += lidFiltered[i].angle;
	}

	cargoCentrePoint.angle = cargoAngle / (cargoEndIndex - cargoStartIndex + 1);	// sets the cargo angle to the average angle of all the points on the cargo
	cargoCentrePoint.dist = basePointDistance + (int)CARGO_RADIUS;					// sets the cargo distance to the group's base point distance plus the cargo's radius
}

////////////////////////////////////////////////////////////// ROCKET HATCH FINDING //////////////////////////////////////////////////////////////////////

tpPoint Lidar::findRocketHatch() {

	// ReadLidar() and FindLines() will be run from the command from where this is called

	// iterate through all the lines forwards
	for (int line = 0; line < linecnt - 2; line++) {

		// if the current line is the right length to be a rocketship fin
		if (lines[line].length < MAX_ACCPETED_ROCKET_FIN_LENGTH && lines[line].length > MIN_ACCPETED_ROCKET_FIN_LEGNTH) {

			// if either of the next two lines are the side of a rocket (check the next two in case the small side of the fin is visible)
			if ( lineIsRocketSide(&lines[line], &lines[line + 1]) || lineIsRocketSide(&lines[line], &lines[line + 2]) ) {

				// return the centre of the cargo side
				return findRocketSideCentre(&rocketSideLine, true);
			}
		}
	}
	
	// iterate through all the lines backwards
	for (int line = linecnt; line >= 2; line--) {

		// if the current line is the right length to be a rocketship fin
		if (lines[line].length < MAX_ACCPETED_ROCKET_FIN_LENGTH && lines[line].length > MIN_ACCPETED_ROCKET_FIN_LEGNTH) {

			// if either of the previous two lines are the side of a rocket (check the previous two in case the small side of the fin is visible)
			if ( lineIsRocketSide(&lines[line], &lines[line - 1]) || lineIsRocketSide(&lines[line], &lines[line - 2]) ) {

				// return the centre of the cargo side
				return findRocketSideCentre(&rocketSideLine, false);
			}
		}
	}

	tpPoint noRocket;
	noRocket.x, noRocket.y = 0;
	noRocket.tstamp = frc::Timer::GetFPGATimestamp();
	return noRocket;
}

bool Lidar::lineIsRocketSide(tpLine *finLine, tpLine *testLine) {

	if (true) {}

}

// this function returns a x-y point with the centre of the rocketship side
tpPoint Lidar::findRocketSideCentre(tpLine *rocketSideLine, bool forwards) {

	// if we are looking at the left side of the rocket ship (forwards because the lidar reads clockwise)
	if (forwards) {
	
		// store the difference in x and y between the lines start and end points
		// these values are multiplied by a scaler ratio in order to find the centre of the rocket side
		double xDist = (double)(rocketSideLine->end.x - rocketSideLine->start.x);
		double yDist = (double)(rocketSideLine->end.y - rocketSideLine->start.y);
		double distance = ROCKET_SIDE_CENTRE_OFFSET;
		
		// calculates the scaler value to apply to the xDist and yDist values
		double scaler = ( -2.0 * (xDist + yDist) + sqrt( pow((2.0 * (xDist + yDist)), 2.0) - 8.0 * (pow(xDist, 2.0) + pow(yDist, 2.0) - pow(distance, 2.0)) ) ) / 4.0;

		// create rocket side centre point object
		tpPoint rocketSideCentre;
		rocketSideCentre.x = rocketSideLine->start.x + round(scaler * xDist);
		rocketSideCentre.y = rocketSideLine->start.y + round(scaler * yDist);
		rocketSideCentre.tstamp = frc::Timer::GetFPGATimestamp();

		return rocketSideCentre;
	}

	// if we are looking at the right side of the rocket ship (!forwards because the lidar reads clockwise)
	else {

		// store the difference in x and y between the lines start and end points
		// these values are multiplied by a scaler ratio in order to find the centre of the rocket side
		int xDist = rocketSideLine->end.x - rocketSideLine->start.x;
		int yDist = rocketSideLine->end.y - rocketSideLine->start.y;

	}



}

int Lidar::climbDistance() {
	filterData(false,45,45,60,40000);
	//Take the first point and last, find center
	tpPoint p1, p2, pcenter;

	double rad = M_PI * (lidFiltered[0].angle) / 180;
	p1.x = (std::round((lidFiltered[0].dist) * std::cos(rad)));
	p1.y = -(std::round((lidFiltered[0].dist) * std::sin(rad)));

	int last = filteredCount - 1;
	rad = M_PI * (lidFiltered[last].angle) / 180;
	p2.x = (std::round((lidFiltered[last].dist) * std::cos(rad)));
	p2.y = -(std::round((lidFiltered[last].dist) * std::sin(rad)));

	pcenter.x = (p1.x + p2.x) / 2;
	pcenter.y = (p1.y + p2.y) / 2;

	//printf("Fd = %i | x1 = %i , y1 = %i | x2 = %i , y2 = %i | cx = %i, cy = %i\n",filteredCount, p1.x, p1.y, p2.x, p2.y,pcenter.x, pcenter.y);

	return (pcenter.x*-1);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool Lidar::findLoadStation(int range) // Search lines to see if we can find something that looks like the loading station.
	{
	filterData(false,range,range,50,2000);
	bool found = false;
	int state = 0;
	int prev = 0;

	int inc_1 = 0;
	int inc_2 = 0;
	int dec_1 = 0;
	int dec_2 = 0;
	int pnt1X = 0;
	int pnt1Y = 0;
	int pnt2X = 0;
	int pnt2Y = 0;

	m_ScoringFinal.dist = 3000;
	m_ScoringFinal.angle = 360;

	for(int i=5;i<filteredCount;i+=5)
		{
		switch(state)
			{
			case 0: //Looking for increase in distance
				if((lidFiltered[i].dist - lidFiltered[prev].dist) >= 25)
					{
					inc_1 = i;
					inc_2 = prev;
					state = 1;
					}
				break;
			case 1: //Looking for decrease in distance
				if((lidFiltered[prev].dist - lidFiltered[i].dist) >= 25)
					{
					dec_1 = i;
					dec_2 = prev;
					state = 2;
					}
				break;
			case 2: //found both locate target
				{
				//Locate the corners now that we have narrowed it down
				int cor_1 = 0;
				double dist = 0;
				for(int n = inc_2;n<(inc_1);n++)
					{
					double val = fabs(lidFiltered[n].dist - lidFiltered[n+1].dist);
					if(val > dist) 
						{
						dist = val;
						cor_1 = n;
						}

					}

				int cor_2 = 0;
				dist = 0;
				for(int n = dec_2;n<(dec_1);n++)
					{
					double val = fabs(lidFiltered[n].dist - lidFiltered[n+1].dist);
					if(val > dist) 
						{
						dist = val;
						cor_2 = n;
						}

					}
				double rad = M_PI * ((double)lidFiltered[cor_1 - 1].angle) / 180;
				pnt1X = -((((double)lidFiltered[cor_1 - 1].dist) * std::cos(rad)));
				pnt1Y = -((((double)lidFiltered[cor_1 - 1].dist) * std::sin(rad)));

				rad = M_PI * ((double)lidFiltered[cor_2 + 2].angle) / 180;
				pnt2X = -((((double)lidFiltered[cor_2 + 2].dist) * std::cos(rad)));
				pnt2Y = -((((double)lidFiltered[cor_2 + 2].dist) * std::sin(rad)));

				int totalDist = sqrt((pnt1X - pnt2X)*(pnt1X - pnt2X) + (pnt1Y - pnt2Y)*(pnt1Y - pnt2Y));
				if((totalDist > 100)&&(totalDist < 400))
					{
					//frc::SmartDashboard::PutNumber("r_Back",run_regression(cor_1, cor_2-1));
					//frc::SmartDashboard::PutNumber("r_Side1",run_regression(cor_1, (cor_1-10)));
					//frc::SmartDashboard::PutNumber("r_Side2",run_regression(cor_2+1, (cor_2+10)));

					lines[0].start.x = pnt1X;
					lines[0].start.y = pnt1Y;
					lines[0].end.x = pnt2X;
					lines[0].end.y = pnt2Y;

					
					//calculate the center
					double ang = (lidFiltered[cor_1].angle + lidFiltered[cor_2].angle) / 2;
					dist = (lidFiltered[cor_1].dist + lidFiltered[cor_2].dist) / 2;
					//printf("\nFound: %f | %f", ang, dist);

					if((fabs(180 - ang) < fabs(180 - m_ScoringFinal.angle))||(dist < m_ScoringFinal.dist)) {
						//calculate target
						//	vector math. Calculae the direction vector of the midpoint perpenticular to
						//	the vector between pnt1 and pnt2
						double dirX = pnt2Y - pnt1Y;
						double dirY = -(pnt2X - pnt1X);
						//	Convert to unit vector
						double mag = sqrt((dirX * dirX)+(dirY * dirY));
						dirX /= mag;
						dirY /= mag;
						//	calculate target position
						m_targetScoring.x = ((-508) * dirX) + ((pnt2X + pnt1X) / 2);
						m_targetScoring.y = ((-508) * dirY) + ((pnt2Y + pnt1Y) / 2);
						if (m_targetScoring.x != 0)
							m_ScoringAngle2 = atan(((double)m_targetScoring.y) / ((double)m_targetScoring.x)) * 180 / M_PI;
						else
							m_ScoringAngle2 = M_PI;
						if (dirX != 0)							
							m_targetAngle = atan(dirY / dirX) * 180 / M_PI;
						else
							m_targetAngle = 90;
						LidarViewer::Get()->addPointXY(m_targetScoring.x,m_targetScoring.y);

						printf("\nPoints: %i,%i | %i,%i | %f,%f - %f",pnt1X,pnt1Y,pnt2X,pnt2Y,dirX,dirY,mag);

						m_ScoringFinal.dist = dist;
						m_ScoringFinal.angle = ang;
						found = true;
					}
					}
				state = 0;
				}
				//break;
			}
		prev = i;
		}
	if(found) {
		if(logfile.is_open())
			{
			sprintf(buf,"H,%i,%f\n",m_ScoringFinal.dist,m_ScoringFinal.angle);
			logfile.write(buf,strlen(buf));
			}
		LidarViewer::Get()->addPoint(m_ScoringFinal.dist,m_ScoringFinal.angle);
		LidarViewer::Get()->addPointXY(pnt1X,pnt1Y);
		LidarViewer::Get()->addPointXY(pnt2X,pnt2Y);
		LidarViewer::Get()->setLines(0,lines); //Note: Function adds 1 to the number provided

	}
	return found;
	}

bool Lidar::findLoadStation_Lines(double ang) {
	int idxmid,idxst,idxnd,i,j,mindist,score,maxscore;
	int idxmidtp,idxsttp,idxndtp; // temporary index registers.
	bool found;

	filterData(true,120,120,50,2000);
	FindLines();
	//loop through the lines and find the one which intersects the given angle
	// Probably better if we look through all the lines and find a set that
	// "looks" like a target (line of length very near 220mm with lines to either side
	// at pretty much the same angle but about 10cm closer to the robot
	// Test data often returns these 3 lines in direct sequence of each other.
	// In reality, there could easily be 1, 2 or even 3 short lines between the
	// lines we're really looking for.  Ideal target is center of end points of the
	// 2 lines that are closer to the robot.
	// not much of a problem using the center of the line that is further from the robot.
	// For now, lets look for lines that are > 175mm

// Search for line of length 170 to 270 range.  Angle should be in the +45 to -45 range
// We can maybe narrow this a bit based on our approach information.
// Then find a line before and after the line (within 3 lines) with an angle
// that is within +/-5.  Use end points of those 2 lines to get us
// our target point.  Above, it would be end of line 0, start of
// line 2 (in both above examples)
// 
// Seem to have a bit of trouble choosing the correct 3 lines.  
// Note that the end points of the chosen line should be about 10cm further from 
// the lidar unit than then end points of the lines found to be right next to the 
// line that's further in.  Data below ... Center Candidates are 0,6,8
// Correct one is probably 6 if we choose to look at the distance to end points
// instead of center of the line.  Long lines will have a center that is 
// too far from the lidar unit to register correctly.
// 
//Line 0: start(-1394, -747) end(-1420, -726) angle=38.927544 length=33 dist=1587.874365, angst=61.812500, distst=1582, angnd=62.921875, distnd=1595
//Line 1: start(-741, 501) end(-287, 551) angle=6.284780 length=456 dist=735.440004, angst=124.078125, distst=895, angnd=152.484375, distnd=621
//Line 2: start(-310, 715) end(-101, 724) angle=2.465759 length=209 dist=747.653663, angst=156.531250, distst=779, angnd=172.078125, distnd=731
//Line 3: start(-65, 612) end(405, 710) angle=11.778025 length=480 dist=682.510806, angst=173.921875, distst=615, angnd=209.687500, distnd=817
//Line 4: start(546, 874) end(546, 845) angle=-90.000000 length=29 dist=1017.839378, angst=211.984375, distst=1031, angnd=212.859375, distnd=1006
//Line 5: start(564, 836) end(1440, 1029) angle=12.424886 length=897 dist=1368.439988, angst=214.000000, distst=1009, angnd=234.437500, distnd=1770
//Line 6: start(1536, 957) end(1606, 723) angle=-73.345694 length=244 dist=1781.471583, angst=238.078125, distst=1810, angnd=245.750000, distnd=1761
//Found target. Line indecies are 2,1,3, target point is (581,-176) at a distance of 607.072483

//Line 1: start(-911, 508) end(-745, 530) angle=7.549422 length=167 dist=977.212873, angst=119.125000, distst=1043, angnd=125.421875, distnd=914
//Line 2: start(-754, 560) end(-755, 614) angle=88.939088 length=54 dist=955.554813, angst=126.578125, distst=939, angnd=129.109375, distnd=973
//Line 3: start(-735, 622) end(-641, 631) angle=5.469095 length=94 dist=930.172027, angst=130.250000, distst=963, angnd=134.546875, distnd=900
//Line 4: start(-533, 555) end(-211, 611) angle=9.865807 length=326 dist=691.572845, angst=136.156250, distst=769, angnd=160.937500, distnd=646
//Line 5: start(-217, 662) end(-211, 700) angle=81.027373 length=38 dist=713.832613, angst=161.843750, distst=697, angnd=163.250000, distnd=731
//Line 6: start(-196, 701) end(-25, 724) angle=7.660475 length=172 dist=720.447083, angst=164.390625, distst=728, angnd=178.046875, distnd=724
//Line 7: start(-9, 657) end(12, 637) angle=-43.602819 length=29 dist=647.000773, angst=179.171875, distst=657, angnd=181.062500, distnd=637
//Line 8: start(25, 638) end(335, 696) angle=10.597335 length=315 dist=690.861057, angst=182.203125, distst=638, angnd=205.703125, distnd=772
//Line 9: start(404, 788) end(526, 802) angle=6.546291 length=122 dist=921.004886, angst=207.125000, distst=885, angnd=213.234375, distnd=959
//Line 10: start(531, 776) end(531, 745) angle=-90.000000 length=31 dist=927.125126, angst=214.375000, distst=940, angnd=215.500000, distnd=915
//Line 11: start(549, 738) end(728, 753) angle=4.790131 length=179 dist=980.851161, angst=216.656250, distst=920, angnd=224.031250, distnd=1048
//Line 12: start(928, 922) end(1434, 994) angle=8.098395 length=511 dist=1520.698853, angst=225.187500, distst=1308, angnd=235.265625, distnd=1745
//Found target. Line indecies are 6,4,8, target point is (624,-93) at a distance of 630.892225

// Algorithm selects incorrectly at far end of Cargo ship.
//Line 0: start(-1534, 894) end(-1391, 904) angle=4.000186 length=143 dist=1716.288146, angst=120.234375, distst=1775, angnd=123.031250, distnd=1659
//Line 1: start(-995, 684) end(-678, 672) angle=-2.167890 length=317 dist=1076.373541, angst=124.515625, distst=1207, angnd=134.750000, distnd=954
//Line 2: start(-674, 702) end(-643, 754) angle=59.198554 length=60 dist=981.299139, angst=136.156250, distst=973, angnd=139.562500, distnd=991
//Line 3: start(-616, 752) end(-566, 744) angle=-9.090277 length=50 dist=953.302156, angst=140.703125, distst=972, angnd=142.734375, distnd=935
//Line 4: start(-464, 647) end(-110, 619) angle=-4.522454 length=355 dist=695.023741, angst=144.328125, distst=796, angnd=169.937500, distnd=629
//Line 5: start(-120, 710) end(47, 698) angle=-4.109998 length=167 dist=704.919854, angst=170.375000, distst=720, angnd=183.828125, distnd=700
//Line 6: start(60, 660) end(75, 604) angle=-75.004921 length=57 dist=635.541501, angst=185.203125, distst=663, angnd=187.062500, distnd=609
//Line 7: start(87, 604) end(264, 607) angle=0.971022 length=177 dist=629.801556, angst=188.218750, distst=610, angnd=203.468750, distnd=662
//Line 8: start(360, 735) end(1038, 680) angle=-4.637732 length=680 dist=994.208228, angst=206.078125, distst=818, angnd=236.765625, distnd=1241
//Found target. Line indecies are 7,5,8, target point is (716,203) at a distance of 744.221069
// Should have chosen 5 as center (angles 170, 183.8, distances 720, 700), 4 start (a 144.3, 169.9 d 796, 629) and 7 end (a 188.2, 203.5 d 610, 662).
// end angle of 4 is really close to start angle of 5.  start angle of 7 is reasonably close (within 5 deg) to end angle of 5.
// distance of 4 end is 629, 5 start is 720.  distance of 5 end is 700, 7 start is 610.  Really close to 10cm each. This is a very strong match.
// since line 5 is almost exactly 10cm further than lines 4 and 7 end points. Angle are also very close.
// Adjusting comparison algorithm to look at end points of the lines as well.  Let's use a scoring method and select the highest score.
// set as our true target.  We'll also need to consider the target that we are the closest to since we won't necessarily be pointed
// directly at the target that was first selected.  However, it should certainly be the closest one.  Targets with a score above
// a certain threshold are legitimate targets.  If we have more than 1, use the distance and choose the closest one.

//Line 0: start(-917, 1282) end(-541, 1073) angle=-29.067541 length=430 dist=1680.600190, angst=144.421875, distst=1576, angnd=153.250000, distnd=1202
//Line 1: start(-401, 836) end(-232, 761) angle=-23.931025 length=184 dist=1040.183157, angst=154.359375, distst=927, angnd=163.031250, distnd=796
//Line 2: start(-223, 789) end(-177, 832) angle=43.069413 length=62 dist=944.506750, angst=164.218750, distst=820, angnd=167.984375, distnd=851
//Line 3: start(-158, 825) end(-88, 779) angle=-33.310631 length=83 dist=951.723174, angst=169.140625, distst=840, angnd=173.546875, distnd=784
//Line 4: start(-64, 652) end(242, 511) angle=-24.739509 length=336 dist=916.293075, angst=174.421875, distst=655, angnd=205.328125, distnd=565
//Line 5: start(273, 541) end(297, 577) angle=56.309932 length=43 dist=662.818225, angst=206.796875, distst=606, angnd=207.234375, distnd=649
//Line 6: start(309, 572) end(458, 500) angle=-25.790831 length=165 dist=680.068379, angst=208.406250, distst=650, angnd=222.468750, distnd=678
//Line 7: start(444, 436) end(429, 405) angle=-64.179008 length=34 dist=621.634137, angst=225.546875, distst=622, angnd=226.687500, distnd=590
//Line 8: start(448, 405) end(742, 257) angle=-26.720746 length=329 dist=605.476672, angst=227.875000, distst=604, angnd=250.859375, distnd=785
//Line 9: start(881, 294) end(957, 250) angle=-30.068583 length=87 dist=792.729462, angst=251.562500, distst=929, angnd=255.328125, distnd=989
//Line 10: start(962, 231) end(936, 169) angle=-67.249024 length=67 dist=1005.200975, angst=256.500000,
//No Target found for 1, score was -216
//No Target found for 2, score was 0
//No Target found for 3, score was 0
//No Target found for 4, score was 0
//No Target found for 5, score was 0
//Found target. Line indecies are 6,4,8, score=159, target point is (536,383) at a distance of 658.775379
//No Target found for 7, score was 0
//No Target found for 8, score was 0
//No Target found for 9, score was 0
//No Target found for 10, score was 0
//No Target found for 11, score was -302
//No Target found for 12, score was 0

	// Step 1, find the line(s) that's are the correct length
//	for(i = 0; i<(linecnt+1); i++)	
//		{
//		// This first time through, let's calculate distance from 0,0 to the mid point of the line
//		// since that is of interest to us as well.
//		m_ScoringLinePoint.y = ((lines[i].start.x + lines[i].end.x)/2);
//		m_ScoringLinePoint.x = ((lines[i].start.y + lines[i].end.y)/2);
//		m_ScoringLineDist = sqrt(((m_ScoringLinePoint.x)*(m_ScoringLinePoint.x))+((m_ScoringLinePoint.y)*(m_ScoringLinePoint.y)));
//		lines[i].dist200 = m_ScoringLineDist;
//		if ((lines[i].length >= 150)&&(lines[i].length <= 270)&&(lines[i].angle > -40.0)&&(lines[i].angle < 40.0))
//			{ // make sure length is good and it's within the +/- 40 degrees.  Lines closer to vertical are no good.
//			if (lines[i].dist200 < mindist) // if we find a closer one, use that.
//				{
//				idxmid = i; // This is the index of the middle line of the correct length.
//				mindist = lines[i].dist200;
//				}
//			}
//		}

	for(int i = 0; i<(linecnt+1); i++){
		printf("Line %i: start(%i, %i) end(%i, %i) angle=%f length=%i dist=%f, angst=%f, distst=%d, angnd=%f, distnd=%d\n",i, lines[i].start.x,lines[i].start.y, lines[i].end.x,lines[i].end.y,lines[i].angle,lines[i].length,lines[i].dist200,lines[i].lidarAnglest,lines[i].lidarDistst,lines[i].lidarAnglend,lines[i].lidarDistnd);
		}

	idxmid = -1; // Assume we don't find the line of the length we're looking for.
	mindist = 100000; // Go for the closest one.
	maxscore = 0; // Clear the max score variable.
	for (i = 0;i<= linecnt;i++) // Consider all lines in the valid angle and length range
		{
		m_ScoringLinePoint.y = ((lines[i].start.x + lines[i].end.x)/2);
		m_ScoringLinePoint.x = ((lines[i].start.y + lines[i].end.y)/2);
		m_ScoringLineDist = sqrt(((m_ScoringLinePoint.x)*(m_ScoringLinePoint.x))+((m_ScoringLinePoint.y)*(m_ScoringLinePoint.y)));
		lines[i].dist200 = m_ScoringLineDist;

		idxmidtp = i;
		idxsttp = -1;
		idxndtp = -1;
		score = 0;
		if ((lines[i].length >= 110)&&(lines[i].length <= 270)&&(lines[i].angle > -40.0)&&(lines[i].angle < 40.0))
			{ // Look for preceeding lines that match the length angle and distance values.  Generate scores based on this.
			j = i-1; // Begin with previous line.
			found = false;
			while((j >= 0)&&(!found)) // Until we find this line, keep looking till we get to the first line.
				{
				if ((fabs(lines[j].angle - lines[i].angle) <= 12.5)&&(lines[j].length > 150)) // Angle is good and line is at least 15cm long
					{
					score += 100 - abs(lines[i].lidarDistst - lines[j].lidarDistnd - 100); // Closer to 100mm is best.
					idxsttp = j;
					found = true;
					}
				j--;
				}
			j = i + 1;
			found = false;
			while((j <= linecnt)&&(!found))
				{
				if ((fabs(lines[j].angle - lines[i].angle) < 12.5)&&(lines[j].length > 150)) // Angle is a good enough match and it's at least 15cm long
					{
					score += 100 - abs(lines[i].lidarDistnd - lines[j].lidarDistst - 100); // Closer to 100mm is best.
					idxndtp = j;
					found = true;
					}
				j++;
				}
			}
		if ((score > 50)&&(idxsttp != -1)&&(idxndtp != -1)) // Any scores above 50 are legit.  Score max is 200.
			{ // If we happen to have more than 1 score over 50, go for the nearest one.
			if (lines[i].dist200 < mindist)
				{
				mindist = lines[i].dist200; // Track lowest distance 
				maxscore = score; // This is the new high score.				
				idxmid = idxmidtp;
				idxst = idxsttp;
				idxnd = idxndtp;
				printf("Found target.  Line indecies are %d,%d,%d, score=%d, target point is (%d,%d) at a distance of %f\n",idxmid,idxst,idxnd,score,m_ScoringLinePoint.x,m_ScoringLinePoint.y,m_ScoringLineDist);
				}
			else
				printf("Ignored farther target.  Line indecies are %d,%d,%d, score=%d, target point is (%d,%d) at a distance of %f\n",idxmid,idxst,idxnd,score,m_ScoringLinePoint.x,m_ScoringLinePoint.y,m_ScoringLineDist);
			}
		else
			{
			printf("No Target found for %i, score was %d\n",i,score);
			}
		
		}

	if ((idxmid != -1)&&(idxst != -1)&&(idxnd != -1)) // If we got all 3, use mid point as the target.
		{
		m_ScoringLinePoint.y = ((lines[idxst].end.x + lines[idxnd].start.x)/2);
		m_ScoringLinePoint.x = ((lines[idxst].end.y + lines[idxnd].start.y)/2);
		if (m_ScoringLinePoint.x != 0)
			{
			m_ScoringLineDist = sqrt(((m_ScoringLinePoint.x)*(m_ScoringLinePoint.x))+((m_ScoringLinePoint.y)*(m_ScoringLinePoint.y)));
			m_ScoreLineAngle = atan((double)m_ScoringLinePoint.y / (double)m_ScoringLinePoint.x) * 180 / M_PI; // Angle from Lidar to Target.
			// printf("Found target.  Line indecies are %d,%d,%d, target point is (%d,%d) at a distance of %f\n",idxmid,idxst,idxnd,m_ScoringLinePoint.x,m_ScoringLinePoint.y,m_ScoringLineDist);
			return true; // We've found a target for the waist and arm.  Go for it.
			}
		}


	/*
	for(int i = 0; i<(linecnt+1); i++){
		double angStart = atan(((double)lines[i].start.y) / ((double)lines[i].start.x)) * 180 / M_PI;
		double angEnd = atan(((double)lines[i].end.y) / ((double)lines[i].end.x)) * 180 / M_PI;
		if((ang > angStart)&&(ang < angEnd)) {
			if((lines[i].length < 100) || (lines[i].length > 400))
				continue; //Line is either too small or too large
			//This is the line that intersets our given angle
			m_ScoreLineAngle = ((angStart + angEnd)/2);
			m_ScoringLinePoint.y = ((lines[i].start.x + lines[i].end.x)/2);
			m_ScoringLinePoint.x = ((lines[i].start.y + lines[i].end.y)/2);
			m_ScoringLineDist = sqrt(((m_ScoringLinePoint.x)*(m_ScoringLinePoint.x))+((m_ScoringLinePoint.y)*(m_ScoringLinePoint.y)));
			return true;
		}
	}
	*/
	//If one is not found then we may want to implement code that will find the loading station
	//	based on the lines
	return false;
}

double Lidar::run_regression(int startIndex, int endIndex){
		double meanX = 0.0;
		double sumX = 0.0;
		double sumX_sq = 0.0;
		double Sxx = 0.0;

		double meanY = 0.0;
		double sumY = 0.0;
		double sumY_sq = 0.0;
		double Syy = 0.0;
		
		double sumXY = 0.0;
		double Sxy = 0.0;

		double rad = 0.0;
		double pntX = 0.0;
		double pntY = 0.0;

		double numPoints = 0;
		
	    for (int i=startIndex;i<endIndex+1;i++){
			//Convert to x,y
			rad = M_PI * ((double)lidFiltered[i].angle) / 180;
			pntX = -((((double)lidFiltered[i].dist) * std::sin(rad)));
			pntY = ((((double)lidFiltered[i].dist) * std::cos(rad)));
			
	    	sumX = sumX + pntX;
	    	sumX_sq = sumX_sq + (pntX * pntX);
		    
	    	sumY = sumY + pntY;
	    	sumY_sq = sumY_sq + (pntY * pntY);
	    	
	    	sumXY = sumXY + pntX * pntY;

			numPoints++;
	    }
	    
	    meanX = sumX / numPoints;
	    Sxx = (sumX_sq / numPoints) - (meanX * meanX);
	    
	    meanY = sumY / numPoints;
	    Syy = (sumY_sq / numPoints) - (meanY * meanY);
	    
	    Sxy = (sumXY / numPoints) - (meanX * meanY);
	    
	    r_B = Sxy / Sxx;
	    r_A = meanY - (r_B * meanX); 
	    r_r = Sxy / (sqrt(Sxx)*sqrt(Syy));

		return r_r;
	}

// Finding Rocket scoring reference point.
// Approach is to locate the line made by the fin of the rocket (near 90 degrees)
// Test data (left rocket) resulted in a line at 78.9 degrees
// Then look for 2 shorter lines  (might be 1 longer line) that are at an angle of about 20 degrees
// The difference between the fin and the smaller line(s) works out to about 60 degrees difference.
// On the right, longer line angle 56.14 (len=394), shorter ones 7.98 (len = 72mm) and 3.03 (len = 170mm)
// on the right, long line will be found last (due to clockwise lidar scanning)
// There can easily be lines the preceed and follow the long line of the fin on the rocket.
// With a hatch panel covering the lower opening ...
// 

// Ideally, the following will work for both far (for drive to) and near for waist positioning.
//Line 4: start(-1133, 1187) end(-891, 1758) angle=67.031902 length=620 dist=0.000000, angst=136.343750, distst=1641, angnd=153.140625, distnd=1971
//Line 5: start(-781, 1831) end(-741, 1841) angle=14.036243 length=41 dist=0.000000, angst=156.906250, distst=1990, angnd=158.078125, distnd=1985
//Line 6: start(-647, 1728) end(-531, 1734) angle=2.960936 length=116 dist=0.000000, angst=159.468750, distst=1845, angnd=162.984375, distnd=1813
//Line 7: start(-280, 1753) end(-137, 1778) angle=9.916526 length=145 dist=0.000000, angst=170.921875, distst=1775, angnd=175.593750, distnd=1783
//+ fin = 4, face = 6
//+ fin = 4, face = 7
// Verify distance from start of 6 to end of 7 is near 550mm.   Start 6 to end 7 is (647-137),(1778-1728) -> 512.5

//Line 0: start(-1823, -306) end(-1795, -152) angle=79.695154 length=156 dist=1821.731594, angst=80.484375, distst=1848, angnd=85.171875, distnd=1801
//Line 1: start(-1851, -118) end(-1989, -54) angle=24.880367 length=152 dist=1951.640592, angst=86.343750, distst=1855, angnd=88.453125, distnd=1990
//Line 2: start(-1532, 413) end(-1504, 472) angle=64.612094 length=65 dist=1578.655441, angst=105.078125, distst=1587, angnd=107.421875, distnd=1576
//Line 3: start(-1318, 1069) end(-1189, 1074) angle=2.219656 length=129 dist=1646.635965, angst=129.046875, distst=1697, angnd=132.093750, distnd=1602
//Line 4: start(-1175, 1105) end(-1132, 1203) angle=66.309311 length=107 dist=1784.158065, angst=133.250000, distst=1613, angnd=136.734375, distnd=1652
//Line 5: start(-968, 1554) end(-887, 1770) angle=69.443955 length=230 dist=1986.769237, angst=148.093750, distst=1831, angnd=153.390625, distnd=1980
//Line 6: start(-810, 1816) end(-738, 1826) angle=7.907163 length=72 dist=1828.163286, angst=155.953125, distst=1989, angnd=158.000000, distnd=1969
//Line 7: start(-634, 1708) end(-523, 1719) angle=5.659482 length=111 dist=1775.700707, angst=159.640625, distst=1822, angnd=163.093750, distnd=1797
//Line 8: start(-278, 1738) end(-138, 1768) angle=12.094757 length=143 dist=-0.000000, angst=170.921875, distst=1760, angnd=175.531250, distnd=1773
//- fin = 5, face = 3
//+ fin = 5, face = 6
//+ fin = 5, face = 7
//+ fin = 5, face = 8
// Dist 6 to 7 302.98, 6 to 8=673.71, 7 to 8=499.61 - closest to 550mm. so 6, 7 is good.  It's also true that 7,8 would be close to on the same
// line but 6 would not sit on that same line.  There should be a way to detect this (if necessary).
//Line 0: start(-1823, -296) end(-1793, -143) angle=78.906277 length=155 dist=1829.807640, angst=80.765625, distst=1847, angnd=85.437500, distnd=1799
//Line 1: start(-1918, -65) end(-1989, -45) angle=15.732005 length=73 dist=1927.660759, angst=88.046875, distst=1919, angnd=88.703125, distnd=1990
//Line 2: start(-1520, 449) end(-1504, 478) angle=61.113418 length=33 dist=1580.892469, angst=106.453125, distst=1585, angnd=107.625000, distnd=1578
//Line 3: start(-1238, 1081) end(-1186, 1068) angle=-14.036243 length=53 dist=1614.371085, angst=131.125000, distst=1644, angnd=132.015625, distnd=1596
//Line 4: start(-1168, 1105) end(-1129, 1206) angle=68.886500 length=108 dist=1624.236744, angst=133.421875, distst=1608, angnd=136.906250, distnd=1652
//Line 5: start(-959, 1552) end(-876, 1768) angle=68.980266 length=231 dist=1901.523863, angst=148.281250, distst=1825, angnd=153.625000, distnd=1973
//Line 6: start(-803, 1820) end(-726, 1824) angle=2.973731 length=77 dist=1978.529252, angst=156.203125, distst=1989, angnd=158.281250, distnd=1963
//Line 7: start(-628, 1717) end(-513, 1722) angle=2.489553 length=115 dist=1806.927226, angst=159.921875, distst=1828, angnd=163.421875, distnd=1797
//Line 8: start(-266, 1743) end(-159, 1752) angle=4.807954 length=107 dist=1756.087982, angst=171.328125, distst=1763, angnd=174.812500, distnd=1759
//- fin = 5, face = 1
//+ fin = 5, face = 6
//+ fin = 5, face = 7
//+ fin = 5, face = 8
// 6 to 7 = 306.11, 7 to 8=470.3 6 to 8=647.5
// If we limit the range to 450 to 560, we will likely be able to pick out 90+% of the correct short lines.
// 
// Note:  On the right side, all angles are -ve.  At least we're looking for -45 to -90 for a fin.
//
// findRocket_Lines() will return true if it finds a rocket.
// variables m_targetScoring.x and m_targetScoring.y are set
// 
bool Lidar::findRocket_Lines() {
	int idxmid,idxst,idxnd,i,j,k,j2,k2,mindist,score,maxscore;
	int idxmidtp,idxsttp,idxndtp; // temporary index registers.
	bool found;
	int tstx[8],tsty[8],tndx[8],tndy[8],tidx[8],tcnt; // small array to help find the right line(s) for face of rocket.
	double tdist,fdist;
	double anglel,angleh;
	double dirX,dirY,mag;								

	filterData(true,119,119,50,2000); // *** using 119, 119 will shift the angle to correct for the 3.5 degree
	// discrepancy we seem to be getting for finding the rocket.  If we're aiming to the right, 
	// then the actual angle needs to have 3.5 degrees added to it to correct for things.
	// An angle of 0 will read as 3.5.  Let's try 8 degrees just to be sure.
	FindLines();

//	for(int i = 0; i<(linecnt+1); i++){
//		if (lines[i].length != 0)
////			printf("Line %i: start(%i, %i) end(%i, %i) angle=%f length=%i dist=%f, angst=%f, distst=%d, angnd=%f, distnd=%d\n",i, lines[i].start.x,lines[i].start.y, lines[i].end.x,lines[i].end.y,lines[i].angle,lines[i].length,lines[i].dist200,lines[i].lidarAnglest,lines[i].lidarDistst,lines[i].lidarAnglend,lines[i].lidarDistnd);
//			printf("Line %i: start(%i, %i) end(%i, %i) angle=%f length=%i\n",i, lines[i].start.x,lines[i].start.y, lines[i].end.x,lines[i].end.y,lines[i].angle,lines[i].length);
//		}

	idxmid = -1; // Assume we don't find the line of the length we're looking for.
	mindist = 100000; // Go for the closest one.  Not likely an issue when looking for the rocket.
	maxscore = 0; // Clear the max score variable.
	for (i = 0;i<= linecnt;i++) // Consider all lines in the valid angle and length range
		{
		m_ScoringLinePoint.y = ((lines[i].start.x + lines[i].end.x)/2);
		m_ScoringLinePoint.x = ((lines[i].start.y + lines[i].end.y)/2);
		m_ScoringLineDist = sqrt(((m_ScoringLinePoint.x)*(m_ScoringLinePoint.x))+((m_ScoringLinePoint.y)*(m_ScoringLinePoint.y)));
		lines[i].dist200 = m_ScoringLineDist;

		idxmidtp = i;
		idxsttp = -1;
		idxndtp = -1;
		score = 0;
		if ((lines[i].length >= 200)&&((lines[i].angle > 22.5)&&(lines[i].angle <= 90.0))||((lines[i].angle > -90.0)&&(lines[i].angle <= -22.5)))
			{ // This line looks like the fin on the rocket.
			if (lines[i].angle > 0) // on the left, angle of fin come in as +
				{
				anglel = lines[i].angle - 70;
				angleh = lines[i].angle - 50;
				}
			else // on the right, angle of fin is -
				{
				anglel = lines[i].angle + 50;
				angleh = lines[i].angle + 70;
				}
			
			printf("Fin Found %i\n",i);
			j = i-1; // Begin with previous line to see if we can find the shorter lines about 60 degrees from the fin.
			found = false; // There will either be 2 short ones (5cm to 200cm) or 1 longer one around 554mm
			// With a hatch panel in place, there could easily be 2 lines at the right angle with just about any
			// distance.  The key item here is that their end point(s) should give us the 554mm 
			//	int tstx[8],tsty[8],tndx[8],tndy[8],tidx[8],tcnt; // small array to help find the right line(s) for face of rocket.
			tcnt = 0;
			while(j >= 0) // Find all lines (could be 1, 2 or 3 such lines)  For this case, lets look for 1 or 2.
				{
				if ((lines[j].angle > anglel)&&(lines[j].angle < angleh)&&(lines[j].length > 70)) // Angle is good
					{
//					printf("- fin %d\n",j);
					tdist = sqrt((lines[j].end.x - lines[j].start.x)*(lines[j].end.x - lines[j].start.x) + (lines[j].end.y - lines[j].start.y)*(lines[j].end.y - lines[j].start.y));
					if ((tdist >= 500.0)&&(tdist <= 560.0)) // This single line is likely the target we are looking for.
						{ // Maybe we can verify with a distance check from the end point of the fin line to the midpoint of this one.
						// The distance shouldn't be all that far.  In fact, it should be quite consistent and should measure about 420mm.
						m_ScoringLinePoint.x = (lines[j].start.x + lines[j].end.x) / 2;
						m_ScoringLinePoint.y = (lines[j].start.y + lines[j].end.y) / 2;
						m_ScoringLineDist = sqrt(((m_ScoringLinePoint.x)*(m_ScoringLinePoint.x))+((m_ScoringLinePoint.y)*(m_ScoringLinePoint.y)));
						if (m_ScoringLinePoint.x != 0)
							m_ScoreLineAngle = atan((double)m_ScoringLinePoint.y / (double)m_ScoringLinePoint.x) * 180 / M_PI; // Angle from Lidar to Target.
						else
							m_ScoreLineAngle = 90;						
						fdist = sqrt((lines[i].end.x - m_ScoringLinePoint.x)*(lines[i].end.x - m_ScoringLinePoint.x) + (lines[i].end.y - m_ScoringLinePoint.y)*(lines[i].end.y - m_ScoringLinePoint.y));
						if ((fdist > 350)&&(fdist < 450)) // if distance from fin end point to center of scoring point is near 420mm, 
							{
							// We have our target, no need to look further.
							// Since this routine is used to locate the target when far and when close
							// at this time, provide the line start and end points.  Drivetrain.cpp
							// will need to manage the rest of the calculations.  Find mid point
							// then find target closer to robot perpendicular to the line.
							m_RocketTarget.start.x = lines[j].start.x;
							m_RocketTarget.start.y = lines[j].start.y;
							m_RocketTarget.end.x = lines[j].end.x;
							m_RocketTarget.end.y = lines[j].end.y;

/*
							dirX = lines[j].end.y - lines[j].start.y;
							dirY = -(lines[j].end.x - lines[j].start.x);
							//	Convert to unit vector
							mag = sqrt((dirX * dirX)+(dirY * dirY));
							dirX /= mag;
							dirY /= mag;
							//	calculate target position
							m_targetScoring.x = ((-508) * dirX) + ((lines[j].start.x + lines[j].end.x) / 2);
							m_targetScoring.y = ((-508) * dirY) + ((lines[j].start.y + lines[j].end.y) / 2);
							if (m_targetScoring.x != 0)
								m_ScoringAngle2 = atan(((double)m_targetScoring.y) / ((double)m_targetScoring.x)) * 180 / M_PI;
							else
								m_ScoringAngle2 = M_PI;
							if (dirX != 0)							
								m_targetAngle = atan(dirY / dirX) * 180 / M_PI;
							else
								m_targetAngle = 90;
*/								
							
							 printf("Right Side Single Line Target (%d,%d) mid of (%d,%d)-(%d,%d)\n",m_ScoringLinePoint.x,m_ScoringLinePoint.y,m_RocketTarget.start.x,m_RocketTarget.start.y,m_RocketTarget.end.x,m_RocketTarget.end.y);
							return true;
							}
						}
					if (tcnt < 8) // max of 8 elements.
						{
						tstx[tcnt] = lines[j].start.x;
						tsty[tcnt] = lines[j].start.y;
						tndx[tcnt] = lines[j].end.x;
						tndy[tcnt] = lines[j].end.y;
						tidx[tcnt] = j;					
						tcnt++;
						}	
					}
				j--;
				}
			
			printf("- fin %d lines to check.\n",tcnt);
			for(j = 0;j<tcnt;j++) // search for valid line pair (450 to 560mm between start and end points)
				{
				j2 = tidx[j];
				for(k = j+1;k<tcnt;k++)
					{ // Get distance from start of earlier line to end of later line.
					k2 = tidx[k];
					tdist = sqrt((tstx[k] - tndx[j])*(tstx[k] - tndx[j])+(tsty[k] - tndy[j])*(tsty[k] - tndy[j]));
					fdist = 0;
					if ((tdist >= 450.0)&&(tdist <= 555)) // We have found the line end points that are legit.
						{ // Have a look to see how well the target lines up with the fin end point.
						m_ScoringLinePoint.x = (tstx[j] + tndx[k]) / 2;
						m_ScoringLinePoint.y = (tsty[j] + tndy[k]) / 2;
						m_ScoringLineDist = sqrt(((m_ScoringLinePoint.x)*(m_ScoringLinePoint.x))+((m_ScoringLinePoint.y)*(m_ScoringLinePoint.y)));
						if (m_ScoringLinePoint.x != 0)
							m_ScoreLineAngle = atan((double)m_ScoringLinePoint.y / (double)m_ScoringLinePoint.x) * 180 / M_PI; // Angle from Lidar to Target.
						else
							m_ScoreLineAngle = 90;						
						fdist = sqrt((lines[i].start.x - m_ScoringLinePoint.x)*(lines[i].start.x - m_ScoringLinePoint.x) + (lines[i].start.y - m_ScoringLinePoint.y)*(lines[i].start.y - m_ScoringLinePoint.y));
						if ((fdist > 350)&&(fdist < 450)) // if distance from fin end point to center of scoring point is near 420mm, 
							{
							// We have our target, no need to look further.
							m_RocketTarget.start.x = tstx[k];
							m_RocketTarget.start.y = tsty[k];
							m_RocketTarget.end.x = tndx[j];
							m_RocketTarget.end.y = tndy[j];
							 printf("Right Side 2 Line Target (%d,%d) mid of (%d,%d)-(%d,%d)\n",m_ScoringLinePoint.x,m_ScoringLinePoint.y,m_RocketTarget.start.x,m_RocketTarget.start.y,m_RocketTarget.end.x,m_RocketTarget.end.y);
							return true;
							}
						}
					printf("%d,%d -> (%d,%d) tdist=%f fdist=%f\n",j2,k2,m_ScoringLinePoint.x,m_ScoringLinePoint.y,tdist,fdist);
					}
				}

			j = i + 1;
			tcnt = 0;
			while(j <= linecnt)
				{
				if ((lines[j].angle > anglel)&&(lines[j].angle < angleh)&&(lines[j].length > 70)) // Angle is good
					{
//					printf("+ fin %d\n",j);
					tdist = sqrt((lines[j].end.x - lines[j].start.x)*(lines[j].end.x - lines[j].start.x) + (lines[j].end.y - lines[j].start.y)*(lines[j].end.y - lines[j].start.y));
					if ((tdist >= 500.0)&&(tdist <= 560.0)) // This single line is likely the target we are looking for.
						{ // Maybe we can verify with a distance check from the end point of the fin line to the midpoint of this one.
						// The distance shouldn't be all that far.  In fact, it should be quite consistent and should measure about 420mm.
						m_ScoringLinePoint.x = (lines[j].start.x + lines[j].end.x) / 2;
						m_ScoringLinePoint.y = (lines[j].start.y + lines[j].end.y) / 2;
						m_ScoringLineDist = sqrt(((m_ScoringLinePoint.x)*(m_ScoringLinePoint.x))+((m_ScoringLinePoint.y)*(m_ScoringLinePoint.y)));
						if (m_ScoringLinePoint.x != 0)
							m_ScoreLineAngle = atan((double)m_ScoringLinePoint.y / (double)m_ScoringLinePoint.x) * 180 / M_PI; // Angle from Lidar to Target.
						else
							m_ScoreLineAngle = 90;						
						fdist = sqrt((lines[i].end.x - m_ScoringLinePoint.x)*(lines[i].end.x - m_ScoringLinePoint.x) + (lines[i].end.y - m_ScoringLinePoint.y)*(lines[i].end.y - m_ScoringLinePoint.y));
						if ((fdist > 350)&&(fdist < 450)) // if distance from fin end point to center of scoring point is near 420mm, 
							{
							// We have our target, no need to look further.
							m_RocketTarget.start.x = lines[j].start.x;
							m_RocketTarget.start.y = lines[j].start.y;
							m_RocketTarget.end.x = lines[j].end.x;
							m_RocketTarget.end.y = lines[j].end.y;
							printf("Left Side Single Line Target (%d,%d) mid of (%d,%d)-(%d,%d)\n",m_ScoringLinePoint.x,m_ScoringLinePoint.y,m_RocketTarget.start.x,m_RocketTarget.start.y,m_RocketTarget.end.x,m_RocketTarget.end.y);
							return true;
							}
						}
					if (tcnt < 8) // max of 8 elements.
						{
						tstx[tcnt] = lines[j].start.x;
						tsty[tcnt] = lines[j].start.y;
						tndx[tcnt] = lines[j].end.x;
						tndy[tcnt] = lines[j].end.y;
						tidx[tcnt] = j;					
						tcnt++;
						}	
					}
				j++;
				}

			printf("+ fin %d lines to check.\n",tcnt);
			for(j = 0;j<tcnt;j++) // search for valid line pair (450 to 560mm between start and end points)
				{
				j2 = tidx[j];
				for(k = j+1;k<tcnt;k++)
					{ // Get distance from start of earlier line to end of later line.  This still works, even on the other side of the rocket.
					k2 = tidx[k];
					tdist = sqrt((tndx[k] - tstx[j])*(tndx[k] - tstx[j])+(tndy[k] - tsty[j])*(tndy[k] - tsty[j]));
					fdist = 0;
					if ((tdist >= 450.0)&&(tdist <= 555)) // We have found the line end points that are legit.
						{ // Have a look to see how well the target lines up with the fin start point.
						m_ScoringLinePoint.x = (tstx[j] + tndx[k]) / 2;
						m_ScoringLinePoint.y = (tsty[j] + tndy[k]) / 2;
						fdist = sqrt((lines[i].end.x - m_ScoringLinePoint.x)*(lines[i].end.x - m_ScoringLinePoint.x) + (lines[i].end.y - m_ScoringLinePoint.y)*(lines[i].end.y - m_ScoringLinePoint.y));
						m_ScoringLineDist = sqrt(((m_ScoringLinePoint.x)*(m_ScoringLinePoint.x))+((m_ScoringLinePoint.y)*(m_ScoringLinePoint.y)));
						if (m_ScoringLinePoint.x != 0)
							m_ScoreLineAngle = atan((double)m_ScoringLinePoint.y / (double)m_ScoringLinePoint.x) * 180 / M_PI; // Angle from Lidar to Target.
						else
							m_ScoreLineAngle = 90;						
						if ((fdist > 350)&&(fdist < 450)) // if distance from fin end point to center of scoring point is near 420mm, 
							{
							// We have our target, no need to look further.
							m_RocketTarget.start.x = tstx[j];
							m_RocketTarget.start.y = tsty[j];
							m_RocketTarget.end.x = tndx[k];
							m_RocketTarget.end.y = tndy[k];
							 printf("Left Side 2 Line Target (%d,%d) mid of (%d,%d)-(%d,%d)\n",m_ScoringLinePoint.x,m_ScoringLinePoint.y,m_RocketTarget.start.x,m_RocketTarget.start.y,m_RocketTarget.end.x,m_RocketTarget.end.y);
							return true;
							}
						}
					printf("%d,%d -> (%d,%d) tdist=%f fdist=%f\n",j2,k2,m_ScoringLinePoint.x,m_ScoringLinePoint.y,tdist,fdist);
					}
				}
			}
		}

	return false;
}
