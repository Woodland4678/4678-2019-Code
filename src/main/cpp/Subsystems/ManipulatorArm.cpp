// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Subsystems/ManipulatorArm.h"
#include "Subsystems/Arm/ArmSegment.h"
#include "ctre/phoenix.h"
#include <fstream>
#include "rev/CANSparkMax.h"
#include "Subsystems/Arm/Movement.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../../include/Commands/MoveArm.h"

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

#define SHOULDER_ANGLE_1    165
#define SHOULDER_ANGLE_2      0
#define SHOULDER_ENCODER_1   2732
#define SHOULDER_ENCODER_2    -7055

#define ELBOW_ANGLE_1     -167
#define ELBOW_ANGLE_2     0
#define ELBOW_ENCODER_2   -5208
#define ELBOW_ENCODER_1   -14623

#define WRIST_ANGLE_1     0
#define WRIST_ANGLE_2     180
#define WRIST_ENCODER_1   60
#define WRIST_ENCODER_2   -1919

#define WAIST_ANGLE_1     0
#define WAIST_ANGLE_2     -69
#define WAIST_ENCODER_1   0
#define WAIST_ENCODER_2   -62


#define SHOULDER_POT_1    2884
#define SHOULDER_POT_2    293

#define ELBOW_POT_1    4
#define ELBOW_POT_2    2467

#define WRIST_POT_1    4
#define WRIST_POT_2    2852

#define WAIST_POT_1    582
#define WAIST_POT_2    2135

ManipulatorArm::ManipulatorArm() : frc::Subsystem("ManipulatorArm") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    waist.reset(new rev::CANSparkMax(6, rev::CANSparkMax::MotorType::kBrushless));
    shoulder.reset(new WPI_TalonSRX(10));
    elbow.reset(new WPI_TalonSRX(9));
    wrist.reset(new WPI_TalonSRX(8));
    intakeWheels.reset(new WPI_VictorSPX(11));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	waistPot.reset(new frc::AnalogInput(0));
	shoulderPot.reset(new frc::AnalogInput(1));
	elbowPot.reset(new frc::AnalogInput(2));
	wristPot.reset(new frc::AnalogInput(3));


    m_Segs[0] = new ArmSegment(shoulder, shoulderPot, 33, NULL, 0, 13.7);
    m_Segs[1] = new ArmSegment(elbow,elbowPot,32, m_Segs[0]);
    m_Segs[2] = new ArmSegment(wrist,wristPot,11, m_Segs[1]);
	m_Segs[3] = new ArmSegment(waist,waistPot,14, NULL);

    m_Moves[0] = new ArmMotion(0,0,10,0);
	m_Moves[1] = new ArmMotion(0,0,10,0);
	m_Moves[2] = new ArmMotion(0,0,10,0);
	m_Moves[3] = new ArmMotion(0,0,10,0);
	m_Moves[4] = new ArmMotion(0,0,10,0);
}

bool ManipulatorArm::Init(){

	//Shoulder
    m_Segs[0]->setSensorDirection(true);
    m_Segs[0]->setVoltageLimit(true, 12);
    m_Segs[0]->setPID(1,0,0);
    //m_Segs[0]->setLimits(2619, 165, -7818, -13);
	m_Segs[0]->setEncoderValues(SHOULDER_ENCODER_1, SHOULDER_ANGLE_1, SHOULDER_ENCODER_2, SHOULDER_ANGLE_2);
	m_Segs[0]->setPotValues(SHOULDER_POT_1, SHOULDER_ANGLE_1, SHOULDER_POT_2, SHOULDER_ANGLE_2);
	m_Segs[0]->initEncoderValues();
	
	//Elbow
    m_Segs[1]->setSensorDirection(true); 
	//m_Segs[1]->setEncoderValues(14475, 100, -123, -150);
	m_Segs[1]->setEncoderValues(ELBOW_ENCODER_1, ELBOW_ANGLE_1, ELBOW_ENCODER_2, ELBOW_ANGLE_2);
	m_Segs[1]->setPotValues(ELBOW_POT_1, ELBOW_ANGLE_1, ELBOW_POT_2, ELBOW_ANGLE_2);
	bool com = m_Segs[1]->initEncoderValues();
    m_Segs[1]->setVoltageLimit(true, 12);
    m_Segs[1]->setPID(1,0,0);

	frc::SmartDashboard::PutNumber("Elbow Init",com);

	//Wrist
    m_Segs[2]->setVoltageLimit(true, 8);
	//m_Segs[2]->setEncoderValues(-1919, 180, 60, 0);
	m_Segs[2]->setEncoderValues(WRIST_ENCODER_1, WRIST_ANGLE_1, WRIST_ENCODER_2, WRIST_ANGLE_2);
	m_Segs[2]->setPotValues(WRIST_POT_1, WRIST_ANGLE_1, WRIST_POT_2, WRIST_ANGLE_2);
	m_Segs[2]->initEncoderValues();	
    m_Segs[2]->setPID(1,0,0);
	
	//Waist
	m_Segs[3]->setEncoderValues(WAIST_ENCODER_1, WAIST_ANGLE_1, WAIST_ENCODER_2, WAIST_ANGLE_2);
	m_Segs[3]->setPotValues(WAIST_POT_1, WAIST_ANGLE_1, WAIST_POT_2, WAIST_ANGLE_2);
	m_Segs[3]->initEncoderValues();	
    m_Segs[3]->setPID(1,0,0);

	addPosition(80,-123,-44); 	//Rocket Cargo Low
	addPosition(94,-85,5);		//Rocket Cargo Medium
	addPosition(76,0,58);		//Rocket Cargo High
	addPosition(67,-128,-60);	//19in / Hatchs
	addPosition(95,-100,-5);		//Rocket Hatch Medium
	addPosition(76,-22,54);		//Rocket Hatch High
	addPosition(93,-116,-22);	//Cargo Human Station
	addPosition(109,-106,34);	//Cargo Cargoship
	addPosition(63,-128,25);		//Climb Medium
	addPosition(93,-128,52);		//Climb High
	addPosition(122,-161,-134);	//Carry
	addPosition(93,-128,52);		//Cargo On Ground 		- Not Set
	addPosition(93,-128,52);		//Home 					- Not Set

    //frc::SmartDashboard::PutNumber("Elbow Slope", m_Segs[2]->getConversionSlope());
    //frc::SmartDashboard::PutNumber("Elbow Intercept", m_Segs[2]->getConversionIntercept());
}

void ManipulatorArm::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        //SetDefaultCommand(new MoveArm(0));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void ManipulatorArm::Periodic() {
    // Put code here to be run every loop
	
	//Forward Kinematics
	m_Segs[0]->updateAngles();
	
	m_Segs[1]->setPhysicalAttributes(m_Segs[0]->getEndX(),m_Segs[0]->getEndY());
	m_Segs[1]->updateAngles();
	
	m_Segs[2]->setPhysicalAttributes(m_Segs[1]->getEndX(),m_Segs[1]->getEndY());
	m_Segs[2]->updateAngles();

	m_Segs[3]->updateAngles();
	
	if (logfile.is_open())
		{
		sprintf(buf,"A,%f,%f,%f,%f,%f,%f,%i,%i\n",
			m_Segs[3]->getRelAngle(),
			m_Segs[3]->getAbsAngle(),
			m_Segs[3]->getStartX(),
			m_Segs[3]->getStartY(),
			m_Segs[3]->getEndX(),
			m_Segs[3]->getEndY(),
			m_Segs[3]->getPotentiometerReading(),
			m_Segs[3]->getSelectedSensorValue()
		);
		logfile.write(buf,strlen(buf));

		sprintf(buf,"S,%f,%f,%f,%f,%f,%f,%i,%i\n",
			m_Segs[0]->getRelAngle(),
			m_Segs[0]->getAbsAngle(),
			m_Segs[0]->getStartX(),
			m_Segs[0]->getStartY(),
			m_Segs[0]->getEndX(),
			m_Segs[0]->getEndY(),
			m_Segs[0]->getPotentiometerReading(),
			m_Segs[0]->getSelectedSensorValue()
		);
		logfile.write(buf,strlen(buf));

		sprintf(buf,"E,%f,%f,%f,%f,%f,%f,%i,%i\n",
			m_Segs[1]->getRelAngle(),
			m_Segs[1]->getAbsAngle(),
			m_Segs[1]->getStartX(),
			m_Segs[1]->getStartY(),
			m_Segs[1]->getEndX(),
			m_Segs[1]->getEndY(),
			m_Segs[1]->getPotentiometerReading(),
			m_Segs[1]->getSelectedSensorValue()
		);
		logfile.write(buf,strlen(buf));

		sprintf(buf,"W,%f,%f,%f,%f,%f,%f,%i,%i\n",
			m_Segs[2]->getRelAngle(),
			m_Segs[2]->getAbsAngle(),
			m_Segs[2]->getStartX(),
			m_Segs[2]->getStartY(),
			m_Segs[2]->getEndX(),
			m_Segs[2]->getEndY(),
			m_Segs[2]->getPotentiometerReading(),
			m_Segs[2]->getSelectedSensorValue()
		);
		logfile.write(buf,strlen(buf));
		}

    frc::SmartDashboard::PutNumber("Shoulder Angle", m_Segs[0]->getRelAngle());
	frc::SmartDashboard::PutNumber("Wrist Angle", m_Segs[2]->getRelAngle());
	frc::SmartDashboard::PutNumber("Elbow Angle", m_Segs[1]->getRelAngle());
	frc::SmartDashboard::PutNumber("Waist Angle", m_Segs[3]->getRelAngle());

	frc::SmartDashboard::PutNumber("Shoulder ABS Angle", m_Segs[0]->getAbsAngle());
	frc::SmartDashboard::PutNumber("Wrist ABS Angle", m_Segs[2]->getAbsAngle());
	frc::SmartDashboard::PutNumber("Elbow ABS Angle", m_Segs[1]->getAbsAngle());
	
	frc::SmartDashboard::PutNumber("El Start X", m_Segs[0]->getEndX());
	frc::SmartDashboard::PutNumber("El Start Y", m_Segs[0]->getEndY());
	frc::SmartDashboard::PutNumber("Wr Start X", m_Segs[1]->getEndX());
	frc::SmartDashboard::PutNumber("Wr Start Y", m_Segs[1]->getEndY());
	frc::SmartDashboard::PutNumber("End X", m_Segs[2]->getEndX());
	frc::SmartDashboard::PutNumber("End Y", m_Segs[2]->getEndY());

	
	frc::SmartDashboard::PutNumber("Shoulder Encoder", m_Segs[0]->getSelectedSensorValue());
	frc::SmartDashboard::PutNumber("Wrist Encoder", m_Segs[2]->getSelectedSensorValue());
	frc::SmartDashboard::PutNumber("Elbow Encoder", m_Segs[1]->getSelectedSensorValue());
	frc::SmartDashboard::PutNumber("Waist Encoder", m_Segs[3]->getSelectedSensorValue());

	frc::SmartDashboard::PutNumber("Shoulder Pot", m_Segs[0]->getPotentiometerReading());
	frc::SmartDashboard::PutNumber("Wrist Pot", m_Segs[2]->getPotentiometerReading());
	frc::SmartDashboard::PutNumber("Elbow Pot", m_Segs[1]->getPotentiometerReading());
	frc::SmartDashboard::PutNumber("Waist Pot", m_Segs[3]->getPotentiometerReading());
    
}

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

void ManipulatorArm::openLog(){
	time_t t=time(0);
	struct tm *now;
	if (!logfile.is_open())
		{
		now = localtime(&t);
		sprintf(buf,"/media/sdc/ARMA%02d%02d%02d%02d%02d%02d.txt",now->tm_year,now->tm_mon,now->tm_mday,now->tm_hour,now->tm_min,now->tm_sec);
		logfile.open(buf,std::ios::out | std::ios::binary);
		}
	else {
		now = localtime(&t);
		sprintf(buf,"/media/sdc/ARMA%02d%02d%02d%02d%02d%02d.txt",now->tm_year,now->tm_mon,now->tm_mday,now->tm_hour,now->tm_min,now->tm_sec);
		logfile.open(buf,std::ios::out | std::ios::binary);
	}
}
void ManipulatorArm::CloseLog() {
	if (logfile.is_open())
		logfile.close();
}

bool ManipulatorArm::moveTo(int pos) {
    frc::SmartDashboard::PutNumber("Complete", m_MotionCase);
	
	//Initial Check
    if(pos >= m_PosCnt) //Make sure this position exists
        return true;
	//Make sure the target wasn't suddenly changed without re-initializing the motion
	if((pos != m_TargetPosition) && (m_MotionCase != 0))
		m_MotionCase = 0;
	
	//Motion State Machine
	switch (m_MotionCase) {
		case 0:
			for(int x=0;x<3;x++) {
				m_Moves[x]->setEndAngle(m_Positions[pos][x]);
				m_Moves[x]->setStartAngle(m_Segs[x]->getRelAngle());
				m_Moves[x]->setDuration(5);
			}
			frc::SmartDashboard::PutNumber("Sh Target",m_Positions[pos][0]);
			frc::SmartDashboard::PutNumber("EL Target",m_Positions[pos][1]);
			frc::SmartDashboard::PutNumber("Wr Target",m_Positions[pos][2]);

			frc::SmartDashboard::PutNumber("Mult",m_Moves[0]->getMultiplier());

			m_TargetPosition = pos;
			
            m_MotionCase++;
			break;
		case 1:
			{
			double timer = frc::Timer::GetFPGATimestamp();
			for(int x=0;x<3;x++) 
				m_Moves[x]->setStartTime(timer);
            m_MotionCase++;
			}
			break;
		case 2:
            {
			double timer = frc::Timer::GetFPGATimestamp();
			int done_cnt = 0; //Keeps count of how many motions are complete
			for(int x=0;x<3;x++) {
				//Check if this motion is complete
				if (m_Moves[x]->isComplete(timer)) {
					done_cnt++;
					continue; //If it is skip this one
				}
				//Get the next angle to move to
				double angle1 = m_Moves[x]->calculateNextPoint(timer);
				
				if(angle1 != -1) {
				if(x == 0)
					frc::SmartDashboard::PutNumber("Sh Set",angle1);
				else if(x==1)
					frc::SmartDashboard::PutNumber("El Set",m_Segs[x]->convertAngleToEncoder(angle1));
				else if(x==2)
					frc::SmartDashboard::PutNumber("Wr Set",angle1);
				}
				if(angle1 != -1) //If angle1 = -1 that means the motion is complete, so this is just to make sure that isn't the case
					m_Segs[x]->set(ControlMode::Position, m_Segs[x]->convertAngleToEncoder(angle1));
			}
			printf("%i\n",done_cnt);
			if(done_cnt >= 3)
				m_MotionCase++;			
            }
			break;
		case 3:
			m_CurrentPosition = pos;
            m_MotionCase = 0;
            return true;
	}
	return false;
}

void ManipulatorArm::addPosition(int shoulderAngle, int elbowAngle, int wristAngle) {
    m_Positions[m_PosCnt][0] = shoulderAngle;
    m_Positions[m_PosCnt][1] = elbowAngle;
    m_Positions[m_PosCnt][2] = wristAngle;

    m_PosCnt++;
}

void ManipulatorArm::setShoulderEncoder(int val){
    m_Segs[0]->set(ControlMode::Position, val);
    //shoulder->Set(ControlMode::Position, val);
}

void ManipulatorArm::setElbowEncoder(int val){
    m_Segs[1]->set(ControlMode::Position, val);
    //elbow->Set(ControlMode::Position, val);
}

void ManipulatorArm::setWristEncoder(int val){
    m_Segs[2]->set(ControlMode::Position, val);
    //wrist->Set(ControlMode::Position, val);
}

int ManipulatorArm::getShoulderEncoder(){
    return shoulder->GetSelectedSensorPosition(0);
}
int ManipulatorArm::getShoulderPot(){
    return shoulder->GetSensorCollection().GetAnalogIn();
}

int ManipulatorArm::getWristEncoder(){
    return wrist->GetSelectedSensorPosition(0);
}
int ManipulatorArm::getWristPot(){
    return wrist->GetSensorCollection().GetAnalogIn();
}

int ManipulatorArm::getElbowEncoder(){
    return elbow->GetSelectedSensorPosition(0);
}
int ManipulatorArm::getElbowPot(){
    return elbow->GetSensorCollection().GetAnalogIn();
}

double ManipulatorArm::getWaistEncoder(){
   return waist->GetEncoder().GetPosition();
}
//double ManipulatorArm::getWaistPot(){
//   return waist->GetEncoder().GetPosition();
//}

void ManipulatorArm::setShoulderPID(double p, double i, double d){
    m_Segs[0]->setPID(p,i,d);
}

void ManipulatorArm::setWristPID(double p, double i, double d){
    wrist->Config_kP(0, p, 0);
    wrist->Config_kI(0, i, 0);
    wrist->Config_kD(0, d, 0);
}

void ManipulatorArm::setElbowPID(double p, double i, double d){
    elbow->Config_kP(0, p, 0);
    elbow->Config_kI(0, i, 0);
    elbow->Config_kD(0, d, 0);
}

void ManipulatorArm::setWaistPID(double p, double i, double d){
    waist->GetPIDController().SetP(p);
    waist->GetPIDController().SetI(i);
    waist->GetPIDController().SetD(d);
}

//Intakes
void ManipulatorArm::intakeWheelsSpin(double power){
    intakeWheels->Set(-power);
}

void ManipulatorArm::intakeWheelsOff(){
    intakeWheels->Set(0);
}