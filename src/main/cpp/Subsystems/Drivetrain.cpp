// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "../../include/Subsystems/Drivetrain.h"
#include "../../include/Subsystems/PathFinder/Path.h"
#include "../../include/Commands/DriveRobot.h"
#include "../../include/Commands/RobotDrive.h"
#include "rev/CANSparkMax.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Drivetrain::Drivetrain() : frc::Subsystem("Drivetrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftMaster.reset(new rev::CANSparkMax(13, rev::CANSparkMax::MotorType::kBrushless));
    leftSlaveOne.reset(new rev::CANSparkMax(1, rev::CANSparkMax::MotorType::kBrushless));
    leftSlaveTwo.reset(new rev::CANSparkMax(2, rev::CANSparkMax::MotorType::kBrushless));
    rightMaster.reset(new rev::CANSparkMax(3, rev::CANSparkMax::MotorType::kBrushless));
    rightSlaveOne.reset(new rev::CANSparkMax(4, rev::CANSparkMax::MotorType::kBrushless));
    rightSlaveTwo.reset(new rev::CANSparkMax(5, rev::CANSparkMax::MotorType::kBrushless));
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    m_Path = new PathFinder(0.02,1,1,1,0.545);
    frc::SmartDashboard::PutNumber("Traverse Right",0);
    frc::SmartDashboard::PutNumber("Traverse Left",0);
}

void Drivetrain::InitDefaultCommand() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    SetDefaultCommand(new DriveRobot());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Drivetrain::Periodic() {
	frc::SmartDashboard::PutNumber("GYRO: ", Robot::ahrs->GetAngle());
	frc::SmartDashboard::PutNumber("Right Distance ", (Robot::drivetrain->getRightEncoder() / 0.2183));
    frc::SmartDashboard::PutNumber("Left Distance ", (Robot::drivetrain->getLeftEncoder() / 0.2183));
    frc::SmartDashboard::PutNumber("Left Speed ", (Robot::drivetrain->getLeftSpeed()));

    

}

void Drivetrain::configMotors() {
    leftSlaveOne->Follow(*leftMaster);
    leftSlaveOne->SetSmartCurrentLimit(40,40,40);
    leftSlaveTwo->Follow(*leftMaster);
    leftSlaveTwo->SetSmartCurrentLimit(40,40,40);
    rightSlaveOne->Follow(*rightMaster);
    rightSlaveOne->SetSmartCurrentLimit(40,40,40);
    rightSlaveTwo->Follow(*rightMaster);
    rightSlaveTwo->SetSmartCurrentLimit(40,40,40);
    rightMaster->SetSmartCurrentLimit(40,40,40);
    leftMaster->SetSmartCurrentLimit(40,40,40);

    rightMaster->GetPIDController().SetP(0.05,0);
    rightMaster->GetPIDController().SetI(0,0);
    rightMaster->GetPIDController().SetD(0,0);

    leftMaster->GetPIDController().SetP(0.05,0);
    leftMaster->GetPIDController().SetI(0,0);
    leftMaster->GetPIDController().SetD(0,0);
}

void Drivetrain::setToCoast() { //set at the end of auto as this is the setup for driving
	rightMaster->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake); //in coast (or driver mode) the master should be on brake
	rightSlaveOne->SetIdleMode(rev::CANSparkMax::IdleMode::kCoast);
	rightSlaveTwo->SetIdleMode(rev::CANSparkMax::IdleMode::kCoast);

	leftMaster->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake); //same as above comment
	leftSlaveOne->SetIdleMode(rev::CANSparkMax::IdleMode::kCoast);
	leftSlaveTwo->SetIdleMode(rev::CANSparkMax::IdleMode::kCoast);
}

void Drivetrain::setToBrake() { //called at the beginning of autonomous
	rightMaster->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
	rightSlaveOne->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
	rightSlaveTwo->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);

	leftMaster->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
	leftSlaveOne->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
	leftSlaveTwo->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
}

void Drivetrain::setLeftMotor(double power) {
    leftMaster->Set(power);
}

void Drivetrain::setRightMotor(double power) {
    rightMaster->Set(-power);
}

void Drivetrain::setLeftPosition(double encoder) {
    leftMaster->GetPIDController().SetReference(encoder,rev::ControlType::kPosition);
}

void Drivetrain::setRightPosition(double encoder) {
    rightMaster->GetPIDController().SetReference(encoder, rev::ControlType::kPosition);
}

void Drivetrain::resetGoToDistanceState() {
    goToDistanceState = 0;
}
//void Drivetrain::test(double power){
   // rightSlaveTwo->Set(power);
//}

double Drivetrain::getLeftEncoder() {
   return leftMaster->GetEncoder().GetPosition();
}

double Drivetrain::getRightEncoder() {
    return rightMaster->GetEncoder().GetPosition();
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


void Drivetrain::joystickDriveCalculator() {


    // declare motor power and quadrant varialbes
    double leftPower;
    double rightPower;
    int quadrant;

    // get joystick values
    double joyX = Robot::oi->getdriver()->GetX();
    double joyY = -Robot::oi->getdriver()->GetY();

    // calculate radius squared (used in testing for deadzone and in scalling based on the radius)
    double radiusSquared = joyX*joyX + joyY*joyY;

    // used later to store joyV and drive algoritm function output
    double joyV;

    // used in calculating the motor power (adjusts power based on joystick's distance from centre)
    double radiusScaler = (radiusSquared - deadRadiusSquared) / (1.0 - deadRadiusSquared);


    // Check deadzone
    if (radiusSquared <= deadRadiusSquared) {
        setLeftMotor(0);
        setRightMotor(0);
        //frc::SmartDashboard::PutBoolean("deadzone active:", true);
        return;
    }
    //frc::SmartDashboard::PutBoolean("deadzone active:", false);


    // check quadrant and calculate Z
    if (joyY >= 0.0) {

        // quadrant 1
        if (joyX >= 0.0) {
            quadrant = 1;
            joyV = joyY - joyX;
        }

        // quadrant 2
        else {
            quadrant = 2;
            joyV = joyY + joyX;
        }

    } else {

        // quadrant 3
        if (joyX < 0.0) {
            quadrant = 3;
            joyV = -joyY + joyX;
        }

        // quadrant 4
        else {
            quadrant = 4;
            joyV = -joyY - joyX;
        }
    }
    //frc::SmartDashboard::PutNumber("joyV:", joyV);


    // adjusting joyV to reduce sensitivity (using rational function), this is the core math of the algorithm
    joyV = ((turningFxnCoefficient + 1)*(joyV + 1) - turningFxnCoefficient) / (turningFxnCoefficient + joyV + 1) * radiusScaler;


    // set motor power varialbes based on quadrant
    switch (quadrant) {

        // quadrant 1
        case 1:
            leftPower = radiusScaler;
            rightPower = joyV;
            break;

        // quadrant 2
        case 2:
            leftPower = joyV;
            rightPower = radiusScaler;
            break;
        
        // quadrant 3
        case 3:
            //leftPower = -radiusScaler;
            //rightPower = joyV;
            rightPower = joyY - joyX;
            leftPower = joyY + joyX;
            break;
        
        // quadrant 4
        case 4:
            //leftPower = joyV;
            //rightPower = -radiusScaler;
            rightPower = joyY - joyX;
            leftPower = joyY + joyX;
            break;
    }


    // PutNumber() debug statements
    //frc::SmartDashboard::PutNumber("turning function coefficient:", turningFxnCoefficient);

    frc::SmartDashboard::PutNumber("x:", joyX);
    frc::SmartDashboard::PutNumber("y:", joyY);

    frc::SmartDashboard::PutNumber("quadrant:", quadrant);

    frc::SmartDashboard::PutNumber("radius squared:", radiusSquared);
    frc::SmartDashboard::PutNumber("deadzone squared:", deadRadiusSquared);

    frc::SmartDashboard::PutNumber("radius scaler:", radiusScaler);
    frc::SmartDashboard::PutNumber("drive function output:", joyV);

    frc::SmartDashboard::PutNumber("left motor power:", leftPower);
    frc::SmartDashboard::PutNumber("right motor power:", rightPower);
    

    // set motor power
    setLeftMotor(leftPower);
    setRightMotor(rightPower);
}

double  Drivetrain::percentDone()  const  {
	// Minimum value is 0
	if (leftPercentThere <= 0.0 && rightPercentThere <= 0.0) {
		return 0.0;
	}

	//  Maximum value is 1.0
	if (leftPercentThere >= 1.0 && rightPercentThere >= 1.0) {
		return 1.0;
	} 

    // Return the max of the two values
    return (leftPercentThere > rightPercentThere) ? leftPercentThere : rightPercentThere;
}

int countGoToDist = 0;
bool Drivetrain::goToDistance(double rightCentimeters, double leftCentimeters, double power, int rampUpDistance,
			int rampDownDistance, double startingPower, double endingPower) {
		//SmartDashboard.putNumber("Left Wheels Position", getLeftEncoder());
		//SmartDashboard.putNumber("Right Wheels Position", getRightEncoder());

		// --------------------------------------------------------------------------
		// -----------------------Reset variables if
		// necessary-----------------------
		// --------------------------------------------------------------------------

		// If this method is being called for the first time since it last
		// finished, you want to record the initial encoder values
		if (goToDistanceState == 0) {
			goToDistanceState++;
			startingLeftDistance = getLeftEncoder();
			startingRightDistance = getRightEncoder();
			// Robot.logger.info("Drivetrain",
			// "goToDistance starting encoder values are " + getRightEncoder() +
			// ", " + getLeftEncoder());
		}


		// --------------------------------------------------------------------------
		// ---------------------Get target and current
		// distances---------------------
		// --------------------------------------------------------------------------

		// Get target distance in centimeters
		targetLeft = leftCentimeters * encoderClicksPerCentimeter; // used to be
																	// parameters
		targetRight = rightCentimeters * encoderClicksPerCentimeter; // used to
																		// be
																		// parameters
		//System.out.println(
			//	"hi goToDistanceState=" + goToDistanceState + " " + startingLeftDistance + " " + startingRightDistance + " tleft="+targetLeft+" tright="+targetRight);

		// Get the current distance in centimeters
		currentLeft = fabs(getLeftEncoder() - startingLeftDistance);
		currentRight = fabs(getRightEncoder() - startingRightDistance);
		currentLeftCentimeters = currentLeft / encoderClicksPerCentimeter; // used
																			// to
																			// use
																			// the
																			// parameter
		currentRightCentimeters = currentRight / encoderClicksPerCentimeter; // used
																				// to
																				// use
																				// the
																				// parameter
																				// (same
																				// name)

		// Find the percentage the left and right are to their target
		leftPercentThere = fabs(currentLeft / targetLeft);
		rightPercentThere = fabs(currentRight / targetRight);
		//System.out.println("Percentages At " + leftPercentThere + ", " + rightPercentThere+" CurrentLeft="+currentLeft+" CurrentRight"+currentRight);
		//System.out.println("Leftcm="+currentLeftCentimeters+" Rightcm="+currentRightCentimeters);

		// Initially set the powers to their default values
		leftMotorMultiplier = 1;
		rightMotorMultiplier = 1;

		// --------------------------------------------------------------------------
		// ----------------Adjust powers if one side has gone
		// farther----------------
		// --------------------------------------------------------------------------

		// Difference between how far the left and right have gone
		powerOffset = GO_TO_DISTANCE_CORRECTION_SPEED * fabs(leftPercentThere - rightPercentThere);

		// Only start adjusting the powers once the motors have gone 2 percent
		// of the target distance, to avoid calculation errors
		if (currentRight >= (targetRight * 0.02) && (currentLeft >= (targetLeft * 0.02))) {
			// If the right is closer than the left, increase the left power and
			// decrease the right power
			if (rightPercentThere > (leftPercentThere + 0.001)) {
				leftMotorMultiplier *= 1 + powerOffset;
				rightMotorMultiplier *= 1 - powerOffset;
			}

			// If the left is closer than the right, increase the right power,
			// and decrease the left power
			if ((rightPercentThere + 0.001) < leftPercentThere) {
				leftMotorMultiplier *= 1 - powerOffset;
				rightMotorMultiplier *= 1 + powerOffset;
			}
		}
		//System.out.println("percentages at " + (int)(leftPercentThere * 100) + ", " + (int)(rightPercentThere * 100) + " Power Offset At " + (((int)(1000 * powerOffset)) / 1000.0));
		// --------------------------------------------------------------------------
		// -----------------------Flip the powers if
		// necessary-----------------------
		// --------------------------------------------------------------------------

		// We use the absolute values for setting the powers, so we have to flip
		// the powers based on what direction the robot is going
		if (targetRight < 0) {
			// If the robot is trying to go backwards and has not passed the
			// target
			if (getRightEncoder() - startingRightDistance > targetRight) {
				rightMotorMultiplier *= -1;
			}
		} else {
			// If the robot is trying to go forwards and has passed the target
			if (getRightEncoder() - startingRightDistance > targetRight) {
				rightMotorMultiplier *= -1;
			}
		}

		if (targetLeft < 0) {
			// If the robot is trying to go backwards and has not passed the
			// target
			if (getLeftEncoder() - startingLeftDistance > targetLeft) {
				leftMotorMultiplier *= -1;
			}
		} else {
			// If the robot is trying to go forwards and has passed the target
			if (getLeftEncoder() - startingLeftDistance > targetLeft) {
				leftMotorMultiplier *= -1;
			}
		}

		// --------------------------------------------------------------------------
		// -----------------------------Ramp Down
		// Speeds-----------------------------
		// --------------------------------------------------------------------------

		double rampDownPercentage = 1;
		if (currentRightCentimeters < rampUpDistance) {
			rampDownPercentage = ((currentRightCentimeters / rampUpDistance) * (1 - startingPower)) + startingPower;
			// Robot.logger.info("Drivetrain", "goToDistance ramping down " +
			// (int)(rampDownPercentage * 100) + "%");
		} else if (currentRightCentimeters > fabs(rightCentimeters) - rampDownDistance) {
			rampDownPercentage = (((fabs(rightCentimeters) - currentRightCentimeters) / rampDownDistance)
					* (1 - endingPower)) + endingPower;
			// Robot.logger.info("Drivetrain", "goToDistance ramping down " +
			// (int)(rampDownPercentage * 100) + "%");
		}

		// Robot.logger.debug("Drivetrain", "goToDistance target is " +
		// rightCentimeters + ", " + leftCentimeters + " current is " +
		// (-(int)((getRightEncoder() - startingRightDistance) /
		// Robot.encoderClicksPerCentimeter())) + ", " +
		// (-(int)((getLeftEncoder() - startingLeftDistance) /
		// Robot.encoderClicksPerCentimeter())));

	//	System.out.println("Left Power = "+leftMotorMultiplier * power * rampDownPercentage+" Right Power = "+rightMotorMultiplier * power * rampDownPercentage);
		//printf("\nRight=%f | Left=%f | RTarget=%f | LTarget=%f",(rightMotorMultiplier * power * rampDownPercentage),(leftMotorMultiplier * power * rampDownPercentage),targetRight,targetLeft);
		setRightMotor(rightMotorMultiplier * power * rampDownPercentage);
		setLeftMotor(leftMotorMultiplier * power * rampDownPercentage);

		// If the left and the right both have gone far enough stop the motors,
		// and reset the goToDistanceState so that the next time
		// the method is called, it will record the starting encoder values
		// again
		if (rightPercentThere >= 1 && leftPercentThere >= 1) {
			setLeftMotor(0);
			setRightMotor(0);
			goToDistanceState = 0;
			// System.out.println("Drivetrain goToDistance at target");
			// System.out.println("Drivetrain goToDistance final encoder values
			// are "+ getRightEncoder() + ", " + getLeftEncoder());
			return true;
			
		} 
		//System.out.println(" return false here...");

		return false;
}
double error = 0;
bool Drivetrain::GyroTurn(double current, double turnAmount, double p, double i, double d){
	static double past = 0;
	static double iValue = 0;
	static int counter = 0;
	// Never go more than 180 degrees in either direction with this function so make sure the step over 360 degrees is
	// handled correctly.  eg at 270 , go to 10 error = 10 - 270 = -260, error should be 370 - 270 = 100 (-260 + 360)
	// eg at 30 go to 300, error = 300 - 30 = 270, error should be 300 - 390 = -90 (270 - 360)
	// so, error of less than -180 needs to be adjusted by +360
	// error of more than +180 is adjusted by -360
	error = turnAmount - current;
	if (error < -180.0)
		error += 360.0;
	if (error > 180.0)
		error -= 360.0;
	double pValue = p*error;
	iValue += i*(error);
	double dValue = d*(past - current);
	double totalValue = pValue + iValue + dValue;

	printf("Gyro: %f  tv = %f\n",current, totalValue);

	if(totalValue > 0.8)
		totalValue = 0.8;
	if(totalValue < -0.8)
		totalValue = -0.8;
	totalValue *= 0.75;
	setRightMotor(-totalValue);
	setLeftMotor(totalValue);


	past = current;
	if ((std::abs(error) < 1.5)||((fabs(totalValue) < 0.1)&&(fabs(error) < 8))) {
		counter++;
	} else {
		counter = 0;
	}
	if(counter >= 10){
		past = 0;
		iValue = 0;
		counter = 0;
		setRightMotor(0);
		setLeftMotor(0);
		return true;
	}
	return false;
}


void Drivetrain::initAutoScore() {
	as_m_case = 0;
	as_move1 = false;
	as_m_SubCase = 0;
	as_mode = 0; 
}

enum { // Cases for autoScore
    autoScoreInit,
    autoScoreReadLidar1,
    autoScoreExamineLidar,
    autoScoreFindLoadStation,
    autoScoreFoundLoadStation,
    autoScoreHavePath,
    autoScorePathComplete,
    autoScoreScanForWaist,
    autoScoreLidarForWaist,
    autoScoreWaistHasMoved,
    autoScoreReadyForPickPlace,
    autoScorePickPlaceComplete,
};

// autoScore - Next Steps:
// 1. If Initial scan shows we're close enough that everything can be done with the arm (no drive base movement)
// then set up for waist scans and proceed to autoScorePathComplete
// 1.5 Look at speeding things up.  Maybe look at path code to see if we can increase speed and/or
// acceleration.  Initial test messed up the overal distance.  May just need to ensure we leave
// motor command as go to position instead of a power of 0 in which case some coasting will take place
// can easily do a power level of 0 a bit later in the process to ensure they're ready for normal
// drivetrain operation.
// 2. Modify how far arm pushes forward based on distance reading.  Right now, it just moves to a fixed
// position.  We should be able to push forward 2" further with the hatch clamp than with the cargo holder.
// 3. Implement code to find rocket - similar to finding hatch panel indent but will need to accommodate
// situation where rocket has a hatch on it and it's placed low.  Gap will not necessarily have a backing to
// it so we won't find a useable line at the back of the gap.  Scoring on rocket will need to work for
// low, med and high levels.  For Med and High, robot can (and should) be positioned closer to the rocket
// than is possible for low scoring.
// 4. Consider auto scoring of cargo.
// 5. Consider auto pickup of cargo.

// If we have more trouble with the path generation, here's the distance - based algorithm:
//         ------------------------------------
//        / |                                 |\
//       /  |                                 | \
//      /   |                                 |  \
//     /    |                                 |   \
//    t0   t1                                t2   t3
//    <-d1-> <-------------- d2 ------------> <-d3->
//  Also given acceleration a, total distance required dReq, max velocity vMax and cycleTime (1/50.0)
// t1 = Vmax / a
// d1 = 0.5 * a * t1^2, d3 = d1
// if (2 * d1 > dReq) // No cruise is reached, purely accel then decel
//     d1 = dReq / 2, d2 = 0, d3 = d1
//     t1 = sqrt(2 * d1 / a), t2 = t1, t3 = t2 + t1
// else // we have a cruise section
//     d2 = dReq - 2 * d1
//     t2 = t1 + d2 / vMax
//     t3 = t2 + t1
// to generate the path ...
// for(double tcnt = 0;tcnt < t3;tcnt += cycleTime)
//     if (tcnt < t1)
//         d = 0.5 * a * tcnt * tcnt
//     else if (tcnt < t2)
//         d = d1 + vMax * (tcnt - t1)
//     else if (tcnt < t3)
//         d = d1 + d2 + d3 - 0.5 * a * (t3 - tcnt) * (t3 - tcnt)
// 
// d = d1 + d2 + d3 // should be our final position calculation.
// 

//Returns   0->not finished yet
//          1->Finished
//          2->Failed to find target
//          3->Failed to find target after driving forwards
int Drivetrain::autoScore(bool autoBack) {
    double waistAngle,distFromWaist;

	switch (as_m_case) {
        case  autoScoreInit:
            Robot::manipulatorArm->m_CurrentPosition = 0;
            //as_move1 = true;
            if(Robot::manipulatorArm->ifHatch()){
//                as_move1 = Robot::manipulatorArm->moveToXY(17.0,26.0,-182.0,0,20.0); //Hatch scoring position
                as_move1 = Robot::manipulatorArm->moveToXY(17.0,22.0,-182.0,0,20.0); //*** Practice Bot ***
                as_mode = 0; // We have a hatch.  We want to place it.
            }
            //else if (Robot::manipulatorArm->ifCargo()){
            //    as_move1 = Robot::manipulatorArm->moveToXY(18.0,48.0,-33,0,20.0); //Cargo Scoring Cargoship
            //    as_mode = 1; // We have a cargo ball.  We want to score it.
            //}
            else 
                {
                //if(Robot::manipulatorArm->isHatchMode()){
//                    as_move1 = Robot::manipulatorArm->moveToXY(17.0,26.0,-182.0,0,20.0); //Hatch Pickup
                    as_move1 = Robot::manipulatorArm->moveToXY(17.0,22.0,-182.0,0,20.0); // *** Practice Bot ***
                    as_mode = 2; // We do not have a hatch.  We want to retrieve one.
                //}
                /*else
                    {
                    as_move1 = Robot::manipulatorArm->moveToXY(9.0,41.0,4.0,0,20.0); //Cargo Pickup
                    as_mode = 3; // We do not have a cargo ball.  We want to get one.
                    if(as_move1)
                        {
                        Robot::manipulatorArm->setInCargoPosition();
                        // Start intake rollers.  Move to any other position will stop them.
                        Robot::manipulatorArm->intakeWheelsSpin(-0.5); // Wheel running.
                        }
                    Robot::manipulatorArm->m_CurrentPosition = 5;
                    }*/
                }
            if(as_move1){
                as_m_case = autoScoreReadLidar1; // Move on to case where we read lidar for drivebase approach.
				as_initGyro = Robot::ahrs->GetAngle();
				
				as_initGyro = 0;
				as_currentGyro = 0;
				as_PrevGyro = 0;
				as_PrevAngle = as_angle;
				as_PrevDistance = as_distance;
				as_PrevGyro = as_currentGyro;

				as_currentGyro = as_initGyro;
                as_lidarScanCount = 0;
			}
            break;
        case autoScoreReadLidar1:
            Robot::lidar->readLidar();
            as_m_case = autoScoreExamineLidar;
            break;
        case autoScoreExamineLidar:
            if(Robot::lidar->readComplete()) {
                as_m_case = autoScoreFindLoadStation;
                //if(as_m_SubCase == 0)
                //    as_m_case++;
                //else
                //    as_m_case = 6;
            }
                
            break; 
        case autoScoreFindLoadStation:
            if(Robot::lidar->findLoadStation(60))
                as_m_case = autoScoreFoundLoadStation;
            else { // If not found, go back and keep scanning lidar till we find one.
                as_lidarScanCount++;
                as_m_case = autoScoreReadLidar1;
                if(as_lidarScanCount > 3)
                    return 2;
            }
            break;
        case autoScoreFoundLoadStation:
            {
            as_lidarScanCount = 0;
            double max_vel = 3; //m/s
            double max_acc = 4; //m/s^2
            double cycle_time = 1.0/50.0;
            double wheelbase = 0.545;
            //We have the location
            as_angle = Robot::lidar->m_ScoringFinal.angle - 180;
            as_distance = Robot::lidar->m_ScoringFinal.dist;
            as_ang = Robot::lidar->m_targetAngle;

            double tarX = Robot::lidar->m_targetScoring.x;
            double tarY = Robot::lidar->m_targetScoring.y;// + 100;

            printf("\nTarX = %f | TarY = %f | ang=%f",tarX,tarY,as_ang);

            //Calculate radius
            double r = 0;
            double arc_angle, dist;
            if(tarX != 0) {
                r = fabs((tarX*tarX) / (2 * tarY) + (tarY / 2));
                //Waist calculation
                //  Direction vector center of circle to target
                double dir_angle = atan((tarX) / (r - fabs(tarY))) * 180 / M_PI;
                //  angle calculation of the direction vector perpenticular to previous direction
                if(tarY > 0)
                    dir_angle *= -1;
                as_ang = (dir_angle + Robot::lidar->m_ScoringAngle2 + Robot::lidar->m_targetAngle);
                printf("\nr = %f | ANGLES: target = %f | direction = %f | Scoring = %f",r,Robot::lidar->m_targetAngle,dir_angle, Robot::lidar->m_ScoringAngle2);
                as_ang -= 2;
                as_ang *= -1;
                //if(as_ang > 60) {
                //    printf("Waist angle greater then 60! %f",as_ang);
                //    as_m_case = 1;
                //    return true;
                //}
                //Distance calculation
                arc_angle = atan(tarX / (r - fabs(tarY)));
                if((r - tarY) < 0)
                    arc_angle = M_PI - arc_angle;
                dist = r * arc_angle;
                if(tarY > 0) { //Left wheel will turn more
                    kl = 1 + ((545.0 / 2) / r);
                    kr = 1 - ((545.0 / 2) / r);
                    //as_ang *= -1;
                }
                else {
                    kr = 1 + ((545.0 / 2) / r);
                    kl = 1 - ((545.0 / 2) / r);
                    //as_ang *= -1;
                }
                printf("\nRadius = %f Gains = %f | %f Angle = %f | dist = %f",r,kr,kl,as_ang,dist);
            }
            else { //Drive striaght
                dist = as_distance;
                kr = 1;
                kl = 1;
            }
            
            //Movement calculations
            dist /= 1000;
            double t1 = max_vel / max_acc, t2, t3;
            double d1 = 0.5 * max_acc * (t1*t1), d2, d3 = d1;
            if(2*d1 > dist) { //No cruise
                d1 = dist / 2;
                d2 = 0;
                d3 = d1;
                t1 = sqrt(2 * d1 / max_acc);
                t2 = t1;
                t3 = t2 + t1;
            }
            else {
                d2 = dist - 2 * d1;
                t2 = t1 + d2 / max_vel;
                t3 = t2 + t1;
            }
            printf("\nPath: t1=%f, t2=%f, t3=%f | d1=%f, d2=%f, d3=%f | max_acc=%f | ",t1,t2,t3,d1,d2,d3,max_acc);

            //Path generation
            d[0] = 0;
            int i=0;
            
            for(double tcnt = 0;tcnt<t3;tcnt += cycle_time,i++) {
                if(tcnt < t1)
                    d[i] = 0.5 * max_acc * (tcnt*tcnt);
                else if(tcnt < t2)
                    d[i] = d1 + (max_vel * (tcnt-t1));
                else if(tcnt < t3)
                    d[i] = d1+d2+d3 - (0.5 * max_acc * ((t3-tcnt)*(t3-tcnt)));
            }
            d[i++] = d1+d2+d3;
            mtime = i;
            printf("Elements = %i",i);
            traverseCnt = 0;
            as_m_case = autoScoreHavePath;
            encPrevLeft = getLeftEncoder();
            encPrevRight = getRightEncoder();
            as_prevWaist = Robot::manipulatorArm->getWaistAngle();
            }
			
            break;
        case autoScoreHavePath:
            {
            
            if(traverseCnt >= mtime) {
                //return true;
                as_m_case = autoScorePathComplete;
                Robot::lidar->readLidar(); // Reset lidar indicator so we get a fresh scan.
                as_lidarScanCount = 0; // Keep track of how many times we try to scan.
                as_cnt = 0;
                //return true;
                //Waist should be here, but just to make sure
                as_m_SubCase = 1;
                setLeftMotor(0);
                setRightMotor(0);
            }
            else {
                //Waist Movement
                //Robot::manipulatorArm->moveWaist(as_prevWaist + as_waist_incr);
                as_prevWaist += as_waist_incr;
                //Main path velocity
                double distance = d[traverseCnt];
                double enDist = (distance * 20.81); //velocity is per second not per cycle
                //left wheel
                encLeft = enDist * kl + encPrevLeft;
                encRight = -(enDist * kr) + encPrevRight;
                
                printf("\nCnt = %i | dist = %f | EncLeft = %f EncRight = %f | waist = %f",traverseCnt, distance, encLeft,encRight,as_prevWaist + as_waist_incr);
                setLeftPosition(encLeft);
                setRightPosition(encRight);

                //encPrevRight = encRight;
                //encPrevLeft = encLeft;
                traverseCnt++;
            }


            /*if(m_Path->traverse(traverseCnt,encPrevRight,encPrevLeft,&encRight, &encLeft)) {
                as_m_case = 1;
                as_m_SubCase = 1;
                setLeftMotor(0);
                setRightMotor(0);
            }
            else {
                setLeftPosition(encLeft);
                setRightPosition(encRight);
                encPrevRight = encRight;
                encPrevLeft = encLeft;
                traverseCnt++;
            } */
            /*
            //We have a distance to the nearest scoring spto and we are lined up
            //  distance is based on the lidar not the waist
            as_distWaist = as_distance + 26.6;
            //Now we need to take into account the end effect is on the arm
            if(as_mode == 1)
                as_distEnd = as_distWaist - (Robot::manipulatorArm->getEndEffectorX() * 25.4) + 100;
            else
                as_distEnd = as_distWaist - (Robot::manipulatorArm->getEndEffectorX() * 25.4) - 350;
            //printf("\n%f | %f | %f | %f",distEnd, (Robot::manipulatorArm->getEndEffectorX() * 25.4), distWaist, distance);
            //Bow we can move forward
            as_m_SubCase = 1;
            as_m_case = 6;
            */
            }
            break;
        case autoScorePathComplete:
            if(as_cnt > 25)
                as_m_case = autoScoreScanForWaist;
            as_cnt++;
            break;
        case autoScoreScanForWaist: // Path is complete.  Need to scan lidar for lines that gives us our waist target.
            if(Robot::lidar->readComplete())  // Once this lidar scan is complete, process it.
                {
                as_lidarScanCount++;
                if (as_lidarScanCount > 3)
                    { // Too many re-tries.  Not getting anything.  Time to cancel
                    return 3;
                    }
                else
                    {
                    as_m_case = autoScoreLidarForWaist;
                    }                
                }
            break;
        case autoScoreLidarForWaist: {
            //Recalculate waist angle and move it there, to ensure we are pointed the right direction
            if (!Robot::lidar->findLoadStation_Lines(-as_ang))
                {
                //If not found repeat the scan up to 3 times.
                Robot::lidar->readLidar(); // Reset lidar indicator so we get a fresh scan.
                as_m_case = autoScorePathComplete; // check scan again.  Do this up to 3 times.
                }
            else // Scan is good.  Figure out how much to turn the waist.
                {        
                double tarAngle = Robot::lidar->m_ScoreLineAngle;
                double tarX = Robot::lidar->m_ScoringLinePoint.x;
                double tarY = Robot::lidar->m_ScoringLinePoint.y;
                double tarDist = Robot::lidar->m_ScoringLineDist;
                distFromWaist = sqrt((tarDist*tarDist)+(289.3*289.3)-2*(tarDist)*(289.3)*cos((180-tarAngle) * M_PI/180));
                if (distFromWaist != 0)
                    {
                    waistAngle = -asin((tarDist*sin((180-tarAngle) * M_PI/180))/(distFromWaist)) * 180 / M_PI;
                    if ((waistAngle > -65.0)&&(waistAngle <= 65.0)) // Only proceed with valid angles.
                        {
                        printf("\nWaist: tarAng=%f | x=%f | y=%f | TarDist=%f || wDist=%f | wAngle=%f",tarAngle,tarX,tarY,tarDist,distFromWaist,waistAngle);
                        as_ang = waistAngle;// + 2.0;
                        Robot::manipulatorArm->moveWaist(waistAngle);
                        if (fabs(waistAngle) > 15.0) // Build in a delay if we need to turn the waist rather far (more than 15 deg)
                            as_cnt = (fabs(waistAngle) - 15); // Give us 50 counts for every 50 degrees -> 50 degrees per second.
                        else
                            as_cnt = 0; // No need to wait for angles less than 15.                
                        as_m_case = autoScoreWaistHasMoved; // Carry on to next state.
                        //as_m_case = 99; // Stop at special case 99.
                        }
                    else // Unable to calculate a valid angle.
                        {
                        Robot::lidar->readLidar(); // Reset lidar indicator so we get a fresh scan.
                        as_m_case = autoScorePathComplete; // check scan again.  Do this up to 3 times.
                        }
                    }
                else // distFromWaist gives non-calculatable angle.  Re-do.
                    {
                    Robot::lidar->readLidar(); // Reset lidar indicator so we get a fresh scan.
                    as_m_case = autoScorePathComplete; // check scan again.  Do this up to 3 times.
                    }
                }
            }
            break;
        case autoScoreWaistHasMoved:
            if (as_cnt > 0)
                as_cnt--;
            else // as_cnt is at 0, no need to wait any longer.
            {   
    //            if (Robot::manipulatorArm->moveToXY(25.5,20.0,-182.0,as_ang,20.0)){ //25.5,25.0,-182.0,as_angle,20.0
                if (Robot::manipulatorArm->moveToXY(23.17,19.5,-195.5,as_ang,20.0)){ // ** Practice Bot **
                    as_m_case = autoScoreReadyForPickPlace;
                    as_cnt = 0;
                    if(as_mode == 0)
                        Robot::manipulatorArm->releaseHatch();
                    else if(as_mode == 1)
                        Robot::manipulatorArm->intakeWheelsSpin(1);
                }
            }
            break;
        case autoScoreReadyForPickPlace: // Move forward to pick or place the piece.
            if (Robot::manipulatorArm->moveToXY(27.17,19.5,-195.5,as_ang,20.0)) // ** Practice Bot **
                {
                if((as_mode == 1) || (as_mode == 0)) {
                    as_cnt++;
                    if(as_cnt == 30) // After moving arm forward, wait to ensure hatch is released.
                        as_m_case = autoScorePickPlaceComplete;
                }
                else 
                    {
                    if(Robot::manipulatorArm->ifHatch() || Robot::manipulatorArm->ifCargo())
                        {
                        as_m_case = autoScorePickPlaceComplete;
                        }
                    }
                }
            break;
        case autoScorePickPlaceComplete:
			if(autoBack)
				as_distEnd = 50;
//            if (Robot::manipulatorArm->moveToXY(20.0,20.0,-182.0,as_ang,20.0)){
            if (Robot::manipulatorArm->moveToXY(20.0,20.0,-187.0,as_ang,20.0)){ // *** Practice Bot ***
                as_m_case = autoScoreInit; // Ready for next time.
                Robot::manipulatorArm->grabHatch();
                Robot::manipulatorArm->intakeWheelsSpin(0);
				return 1;
            }
            break;
        case 99: // Special case used to halt further motion ** Testing Only **
            break;
    }
	return 0;
}

double Drivetrain::getLeftSpeed() {
    return leftMaster->GetEncoder().GetVelocity();
}
// double drivetrain::getLeftSpeed() {
//     return leftMaster->GetVelocity();
// }

bool Drivetrain::testPaths() {
    bool complete = false;
    switch(pathCase) {
        case 0:
            m_Path->createNewPath();
            m_Path->addWayPoint(0.0,0.0,0.0);
            m_Path->addWayPoint(1.0,0.5,30.0);

            if (m_Path->makePath()) {
                traverseCnt = 0;
                printf("\nHere");
                encPrevLeft = getLeftEncoder();
                encPrevRight = getRightEncoder();
                pathCase = 1;
            }
            else
                printf("\nPath Failure");
            break;
        case 1:
            m_Path->debug();
            break;
        case 2:
            if(m_Path->traverse(traverseCnt,encPrevRight,encPrevLeft,&encRight, &encLeft)) {
                pathCase = 0;
                //printf("\nDone");
                complete = true;
            }
            else {
                setLeftPosition(encLeft);
                setRightPosition(encRight);
                frc::SmartDashboard::PutNumber("Traverse Right",encRight);
                frc::SmartDashboard::PutNumber("Traverse Left",encLeft);
                //printf("\nCount = %i | Encoders = %f | %f",traverseCnt,encRight,encLeft);
                encPrevRight = encRight;
                encPrevLeft = encLeft;
                traverseCnt++;
            }
            break;
    }
    return complete;
}