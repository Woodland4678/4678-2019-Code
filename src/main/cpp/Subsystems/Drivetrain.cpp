// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "../../include/Subsystems/Drivetrain.h"
#include "../../include/Commands/DriveRobot.h"
#include "../../include/Commands/RobotDrive.h"
#include "rev/CANSparkMax.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Drivetrain::Drivetrain() : frc::Subsystem("Drivetrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftMaster.reset(new rev::CANSparkMax(13, rev::CANSparkMax::MotorType::kBrushless));
    leftSlaveOne.reset(new rev::CANSparkMax(1, rev::CANSparkMax::MotorType::kBrushless));
    leftSlaveTwo.reset(new rev::CANSparkMax(2, rev::CANSparkMax::MotorType::kBrushless));
    rightMaster.reset(new rev::CANSparkMax(3, rev::CANSparkMax::MotorType::kBrushless));
    rightSlaveOne.reset(new rev::CANSparkMax(4, rev::CANSparkMax::MotorType::kBrushless));
    rightSlaveTwo.reset(new rev::CANSparkMax(5, rev::CANSparkMax::MotorType::kBrushless));
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void Drivetrain::InitDefaultCommand() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    SetDefaultCommand(new DriveRobot());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Drivetrain::Periodic() {
	frc::SmartDashboard::PutNumber("GYRO: ", Robot::ahrs->GetAngle());
	frc::SmartDashboard::PutNumber("Right Distance ", (Robot::drivetrain->getRightEncoder() / 0.2183));
    frc::SmartDashboard::PutNumber("Left Distance ", (Robot::drivetrain->getLeftEncoder() / 0.2183));

}

void Drivetrain::configMotors() {
    leftSlaveOne->Follow(*leftMaster);
    leftSlaveOne->SetSmartCurrentLimit(80,80,80);
    leftSlaveTwo->Follow(*leftMaster);
    leftSlaveTwo->SetSmartCurrentLimit(80,80,80);
    rightSlaveOne->Follow(*rightMaster);
    rightSlaveOne->SetSmartCurrentLimit(80,80,80);
    rightSlaveTwo->Follow(*rightMaster);
    rightSlaveTwo->SetSmartCurrentLimit(80,80,80);
    rightMaster->SetSmartCurrentLimit(80,80,80);
    leftMaster->SetSmartCurrentLimit(80,80,80);
}

void Drivetrain::setToCoast() { //set at the end of auto as this is the setup for driving
	rightMaster->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake); //in coast (or driver mode) the master should be on brake
	rightSlaveOne->SetIdleMode(rev::CANSparkMax::IdleMode::kCoast);
	rightSlaveTwo->SetIdleMode(rev::CANSparkMax::IdleMode::kCoast);

	leftMaster->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake); //same as above comment
	leftSlaveOne->SetIdleMode(rev::CANSparkMax::IdleMode::kCoast);
	leftSlaveTwo->SetIdleMode(rev::CANSparkMax::IdleMode::kCoast);
}

void Drivetrain::setToBrake() { //called at the beginning of autonomous
	rightMaster->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
	rightSlaveOne->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
	rightSlaveTwo->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);

	leftMaster->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
	leftSlaveOne->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
	leftSlaveTwo->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
}

void Drivetrain::setLeftMotor(double power) {
    leftMaster->Set(power);
}

void Drivetrain::setRightMotor(double power) {
    rightMaster->Set(-power);
}

void Drivetrain::resetGoToDistanceState() {
    goToDistanceState = 0;
}
//void Drivetrain::test(double power){
   // rightSlaveTwo->Set(power);
//}

double Drivetrain::getLeftEncoder() {
   return leftMaster->GetEncoder().GetPosition();
}

double Drivetrain::getRightEncoder() {
    return rightMaster->GetEncoder().GetPosition();
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


void Drivetrain::joystickDriveCalculator() {


    // declare motor power and quadrant varialbes
    double leftPower;
    double rightPower;
    int quadrant;

    // get joystick values
    double joyX = Robot::oi->getdriver()->GetX();
    double joyY = -Robot::oi->getdriver()->GetY();

    // calculate radius squared (used in testing for deadzone and in scalling based on the radius)
    double radiusSquared = joyX*joyX + joyY*joyY;

    // used later to store joyV and drive algoritm function output
    double joyV;

    // used in calculating the motor power (adjusts power based on joystick's distance from centre)
    double radiusScaler = (radiusSquared - deadRadiusSquared) / (1.0 - deadRadiusSquared);


    // Check deadzone
    if (radiusSquared <= deadRadiusSquared) {
        setLeftMotor(0);
        setRightMotor(0);
        //frc::SmartDashboard::PutBoolean("deadzone active:", true);
        return;
    }
    //frc::SmartDashboard::PutBoolean("deadzone active:", false);


    // check quadrant and calculate Z
    if (joyY >= 0.0) {

        // quadrant 1
        if (joyX >= 0.0) {
            quadrant = 1;
            joyV = joyY - joyX;
        }

        // quadrant 2
        else {
            quadrant = 2;
            joyV = joyY + joyX;
        }

    } else {

        // quadrant 3
        if (joyX < 0.0) {
            quadrant = 3;
            joyV = -joyY + joyX;
        }

        // quadrant 4
        else {
            quadrant = 4;
            joyV = -joyY - joyX;
        }
    }
    //frc::SmartDashboard::PutNumber("joyV:", joyV);


    // adjusting joyV to reduce sensitivity (using rational function), this is the core math of the algorithm
    joyV = ((turningFxnCoefficient + 1)*(joyV + 1) - turningFxnCoefficient) / (turningFxnCoefficient + joyV + 1) * radiusScaler;


    // set motor power varialbes based on quadrant
    switch (quadrant) {

        // quadrant 1
        case 1:
            leftPower = radiusScaler;
            rightPower = joyV;
            break;

        // quadrant 2
        case 2:
            leftPower = joyV;
            rightPower = radiusScaler;
            break;
        
        // quadrant 3
        case 3:
            //leftPower = -radiusScaler;
            //rightPower = joyV;
            rightPower = joyY - joyX;
            leftPower = joyY + joyX;
            break;
        
        // quadrant 4
        case 4:
            //leftPower = joyV;
            //rightPower = -radiusScaler;
            rightPower = joyY - joyX;
            leftPower = joyY + joyX;
            break;
    }


    // PutNumber() debug statements
    //frc::SmartDashboard::PutNumber("turning function coefficient:", turningFxnCoefficient);

    frc::SmartDashboard::PutNumber("x:", joyX);
    frc::SmartDashboard::PutNumber("y:", joyY);

    frc::SmartDashboard::PutNumber("quadrant:", quadrant);

    frc::SmartDashboard::PutNumber("radius squared:", radiusSquared);
    frc::SmartDashboard::PutNumber("deadzone squared:", deadRadiusSquared);

    frc::SmartDashboard::PutNumber("radius scaler:", radiusScaler);
    frc::SmartDashboard::PutNumber("drive function output:", joyV);

    frc::SmartDashboard::PutNumber("left motor power:", leftPower);
    frc::SmartDashboard::PutNumber("right motor power:", rightPower);
    

    // set motor power
    setLeftMotor(leftPower);
    setRightMotor(rightPower);
}

double  Drivetrain::percentDone()  const  {
	// Minimum value is 0
	if (leftPercentThere <= 0.0 && rightPercentThere <= 0.0) {
		return 0.0;
	}

	//  Maximum value is 1.0
	if (leftPercentThere >= 1.0 && rightPercentThere >= 1.0) {
		return 1.0;
	} 

    // Return the max of the two values
    return (leftPercentThere > rightPercentThere) ? leftPercentThere : rightPercentThere;
}

int countGoToDist = 0;
bool Drivetrain::goToDistance(double rightCentimeters, double leftCentimeters, double power, int rampUpDistance,
			int rampDownDistance, double startingPower, double endingPower) {
		//SmartDashboard.putNumber("Left Wheels Position", getLeftEncoder());
		//SmartDashboard.putNumber("Right Wheels Position", getRightEncoder());

		// --------------------------------------------------------------------------
		// -----------------------Reset variables if
		// necessary-----------------------
		// --------------------------------------------------------------------------

		// If this method is being called for the first time since it last
		// finished, you want to record the initial encoder values
		if (goToDistanceState == 0) {
			goToDistanceState++;
			startingLeftDistance = getLeftEncoder();
			startingRightDistance = getRightEncoder();
			// Robot.logger.info("Drivetrain",
			// "goToDistance starting encoder values are " + getRightEncoder() +
			// ", " + getLeftEncoder());
		}


		// --------------------------------------------------------------------------
		// ---------------------Get target and current
		// distances---------------------
		// --------------------------------------------------------------------------

		// Get target distance in centimeters
		targetLeft = leftCentimeters * encoderClicksPerCentimeter; // used to be
																	// parameters
		targetRight = rightCentimeters * encoderClicksPerCentimeter; // used to
																		// be
																		// parameters
		//System.out.println(
			//	"hi goToDistanceState=" + goToDistanceState + " " + startingLeftDistance + " " + startingRightDistance + " tleft="+targetLeft+" tright="+targetRight);

		// Get the current distance in centimeters
		currentLeft = fabs(getLeftEncoder() - startingLeftDistance);
		currentRight = fabs(getRightEncoder() - startingRightDistance);
		currentLeftCentimeters = currentLeft / encoderClicksPerCentimeter; // used
																			// to
																			// use
																			// the
																			// parameter
		currentRightCentimeters = currentRight / encoderClicksPerCentimeter; // used
																				// to
																				// use
																				// the
																				// parameter
																				// (same
																				// name)

		// Find the percentage the left and right are to their target
		leftPercentThere = fabs(currentLeft / targetLeft);
		rightPercentThere = fabs(currentRight / targetRight);
		//System.out.println("Percentages At " + leftPercentThere + ", " + rightPercentThere+" CurrentLeft="+currentLeft+" CurrentRight"+currentRight);
		//System.out.println("Leftcm="+currentLeftCentimeters+" Rightcm="+currentRightCentimeters);

		// Initially set the powers to their default values
		leftMotorMultiplier = 1;
		rightMotorMultiplier = 1;

		// --------------------------------------------------------------------------
		// ----------------Adjust powers if one side has gone
		// farther----------------
		// --------------------------------------------------------------------------

		// Difference between how far the left and right have gone
		powerOffset = GO_TO_DISTANCE_CORRECTION_SPEED * fabs(leftPercentThere - rightPercentThere);

		// Only start adjusting the powers once the motors have gone 2 percent
		// of the target distance, to avoid calculation errors
		if (currentRight >= (targetRight * 0.02) && (currentLeft >= (targetLeft * 0.02))) {
			// If the right is closer than the left, increase the left power and
			// decrease the right power
			if (rightPercentThere > (leftPercentThere + 0.001)) {
				leftMotorMultiplier *= 1 + powerOffset;
				rightMotorMultiplier *= 1 - powerOffset;
			}

			// If the left is closer than the right, increase the right power,
			// and decrease the left power
			if ((rightPercentThere + 0.001) < leftPercentThere) {
				leftMotorMultiplier *= 1 - powerOffset;
				rightMotorMultiplier *= 1 + powerOffset;
			}
		}
		//System.out.println("percentages at " + (int)(leftPercentThere * 100) + ", " + (int)(rightPercentThere * 100) + " Power Offset At " + (((int)(1000 * powerOffset)) / 1000.0));
		// --------------------------------------------------------------------------
		// -----------------------Flip the powers if
		// necessary-----------------------
		// --------------------------------------------------------------------------

		// We use the absolute values for setting the powers, so we have to flip
		// the powers based on what direction the robot is going
		if (targetRight < 0) {
			// If the robot is trying to go backwards and has not passed the
			// target
			if (getRightEncoder() - startingRightDistance > targetRight) {
				rightMotorMultiplier *= -1;
			}
		} else {
			// If the robot is trying to go forwards and has passed the target
			if (getRightEncoder() - startingRightDistance > targetRight) {
				rightMotorMultiplier *= -1;
			}
		}

		if (targetLeft < 0) {
			// If the robot is trying to go backwards and has not passed the
			// target
			if (getLeftEncoder() - startingLeftDistance > targetLeft) {
				leftMotorMultiplier *= -1;
			}
		} else {
			// If the robot is trying to go forwards and has passed the target
			if (getLeftEncoder() - startingLeftDistance > targetLeft) {
				leftMotorMultiplier *= -1;
			}
		}

		// --------------------------------------------------------------------------
		// -----------------------------Ramp Down
		// Speeds-----------------------------
		// --------------------------------------------------------------------------

		double rampDownPercentage = 1;
		if (currentRightCentimeters < rampUpDistance) {
			rampDownPercentage = ((currentRightCentimeters / rampUpDistance) * (1 - startingPower)) + startingPower;
			// Robot.logger.info("Drivetrain", "goToDistance ramping down " +
			// (int)(rampDownPercentage * 100) + "%");
		} else if (currentRightCentimeters > fabs(rightCentimeters) - rampDownDistance) {
			rampDownPercentage = (((fabs(rightCentimeters) - currentRightCentimeters) / rampDownDistance)
					* (1 - endingPower)) + endingPower;
			// Robot.logger.info("Drivetrain", "goToDistance ramping down " +
			// (int)(rampDownPercentage * 100) + "%");
		}

		// Robot.logger.debug("Drivetrain", "goToDistance target is " +
		// rightCentimeters + ", " + leftCentimeters + " current is " +
		// (-(int)((getRightEncoder() - startingRightDistance) /
		// Robot.encoderClicksPerCentimeter())) + ", " +
		// (-(int)((getLeftEncoder() - startingLeftDistance) /
		// Robot.encoderClicksPerCentimeter())));

	//	System.out.println("Left Power = "+leftMotorMultiplier * power * rampDownPercentage+" Right Power = "+rightMotorMultiplier * power * rampDownPercentage);
		//printf("\nRight=%f | Left=%f | RTarget=%f | LTarget=%f",(rightMotorMultiplier * power * rampDownPercentage),(leftMotorMultiplier * power * rampDownPercentage),targetRight,targetLeft);
		setRightMotor(rightMotorMultiplier * power * rampDownPercentage);
		setLeftMotor(leftMotorMultiplier * power * rampDownPercentage);

		// If the left and the right both have gone far enough stop the motors,
		// and reset the goToDistanceState so that the next time
		// the method is called, it will record the starting encoder values
		// again
		if (rightPercentThere >= 1 && leftPercentThere >= 1) {
			setLeftMotor(0);
			setRightMotor(0);
			goToDistanceState = 0;
			// System.out.println("Drivetrain goToDistance at target");
			// System.out.println("Drivetrain goToDistance final encoder values
			// are "+ getRightEncoder() + ", " + getLeftEncoder());
			return true;
			
		} 
		//System.out.println(" return false here...");

		return false;
}
double error = 0;
bool Drivetrain::GyroTurn(double current, double turnAmount, double p, double i, double d){
	static double past = 0;
	static double iValue = 0;
	static int counter = 0;
	// Never go more than 180 degrees in either direction with this function so make sure the step over 360 degrees is
	// handled correctly.  eg at 270 , go to 10 error = 10 - 270 = -260, error should be 370 - 270 = 100 (-260 + 360)
	// eg at 30 go to 300, error = 300 - 30 = 270, error should be 300 - 390 = -90 (270 - 360)
	// so, error of less than -180 needs to be adjusted by +360
	// error of more than +180 is adjusted by -360
	error = turnAmount - current;
	if (error < -180.0)
		error += 360.0;
	if (error > 180.0)
		error -= 360.0;
	double pValue = p*error;
	iValue += i*(error);
	double dValue = d*(past - current);
	double totalValue = pValue + iValue + dValue;

	printf("Gyro: %f  tv = %f\n",current, totalValue);

	if(totalValue > 0.8)
		totalValue = 0.8;
	if(totalValue < -0.8)
		totalValue = -0.8;
	totalValue *= 0.75;
	setRightMotor(-totalValue);
	setLeftMotor(totalValue);


	past = current;
	if ((std::abs(error) < 1.5)||((fabs(totalValue) < 0.1)&&(fabs(error) < 8))) {
		counter++;
	} else {
		counter = 0;
	}
	if(counter >= 10){
		past = 0;
		iValue = 0;
		counter = 0;
		setRightMotor(0);
		setLeftMotor(0);
		return true;
	}
	return false;
}


void Drivetrain::initAutoScore() {
	as_m_case = 0;
	as_move1 = false;
	as_m_SubCase = 0;
	as_mode = 0; 
}

bool Drivetrain::autoScore(bool autoBack) {
	switch (as_m_case) {
        case  0:
            Robot::manipulatorArm->m_CurrentPosition = 0;
            if(Robot::manipulatorArm->ifHatch()){
                as_move1 = Robot::manipulatorArm->moveToXY(25.5,19.0,-190,0,20.0); //Hatch scoring position
                as_mode = 0;
            }
            else if (Robot::manipulatorArm->ifCargo()){
                as_move1 = Robot::manipulatorArm->moveToXY(18.0,48.0,-33,0,20.0); //Cargo Scoring Cargoship
                as_mode = 1;
            }
            else 
                {
                if(Robot::manipulatorArm->isHatchMode()){
                    as_move1 = Robot::manipulatorArm->moveToXY(28.5,20.0,-190.0,0,20.0); //Hatch Pickup
                    as_mode = 2;
                }
                else
                    {
                    as_move1 = Robot::manipulatorArm->moveToXY(9.0,41.0,4.0,0,20.0); //Cargo Pickup
                    as_mode = 3;
                    if(as_move1)
                        {
                        Robot::manipulatorArm->setInCargoPosition();
                        // Start intake rollers.  Move to any other position will stop them.
                        Robot::manipulatorArm->intakeWheelsSpin(-0.5); // Wheel running.
                        }
                    Robot::manipulatorArm->m_CurrentPosition = 5;
                    }
                }
            if(as_move1)
                as_m_case = 1;
            break;
        case 1:
            Robot::lidar->readLidar();
            as_m_case++;
            break;
        case 2:
            if(Robot::lidar->readComplete())
                as_m_case++;
            break; 
        case 3:
            if(Robot::lidar->findLoadStation())
                {
                if(as_m_SubCase == 0)
                    as_m_case = 4;
                else
                    as_m_case = 6;
                }
            else
                as_m_case = 1;
            break;
        case 4:
            {
            as_angle = Robot::lidar->m_ScoringFinal.angle - 180;
            as_distance = Robot::lidar->m_ScoringFinal.dist;
            //printf("\n%f | %f",angle,distance);
            if((GyroTurn(0, as_angle, 0.008, 0, 0))||(fabs(as_angle) < 5))
                as_m_case = 5;
            else
                as_m_case = 1;
                
            }
            break;
        case 5:
            {
            //We have a distance to the nearest scoring spto and we are lined up
            //  distance is based on the lidar not the waist
            as_distWaist = as_distance + 26.6;
            //Now we need to take into account the end effect is on the arm
            if(as_mode == 1)
                as_distEnd = as_distWaist - (Robot::manipulatorArm->getEndEffectorX() * 25.4) + 300;
            else
                as_distEnd = as_distWaist - (Robot::manipulatorArm->getEndEffectorX() * 25.4) - 250;
            //printf("\n%f | %f | %f | %f",distEnd, (Robot::manipulatorArm->getEndEffectorX() * 25.4), distWaist, distance);
            //Bow we can move forward
            as_m_SubCase = 1;
            as_m_case = 6;
            }
            break;
        case 6:
            as_angle = 180 - Robot::lidar->m_ScoringFinal.angle;
            as_distance = Robot::lidar->m_ScoringFinal.dist;
            //As we drive to this point the angle will change to make up for that turn the waist
            if((as_angle > -67)&&(as_angle < 67)){
                if(as_mode == 0)
                    Robot::manipulatorArm->moveWaist(as_angle);
                else
                    Robot::manipulatorArm->moveWaist(as_angle + 3);
            }

            if (goToDistance(as_distEnd/10,as_distEnd/10, 0.3, 20,10,0.2,0.2)){
                as_m_case = 7;
                as_cnt = 0;
                setLeftMotor(0);
                setRightMotor(0);
                if(as_mode == 0)
                    Robot::manipulatorArm->releaseHatch();
                else if(as_mode == 1)
                    Robot::manipulatorArm->intakeWheelsSpin(1);
            }
            else
                as_m_case = 1;
            break;
        case 7:
            {
            if((as_mode == 1) || (as_mode == 0)) {
                as_cnt++;
                if(as_cnt == 20)
                    as_m_case = 8;
            }
            else 
                {
                if(Robot::manipulatorArm->ifHatch() || Robot::manipulatorArm->ifCargo())
                    {
                    as_m_case = 8;
                    }
                }
            }
            break;
        case 8:
			if(autoBack)
				as_distEnd = 50;
            if (goToDistance(-(as_distEnd/10),-(as_distEnd/10), 0.5, 10,10,0.2,0.2)){
                as_m_case = 0;
                if(as_mode == 0)
                    Robot::manipulatorArm->grabHatch();
                else if(as_mode == 1)
                    Robot::manipulatorArm->intakeWheelsSpin(0);
				return true;
            }
            break;
    }
	return false;
}