// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "../../include/Subsystems/Drivetrain.h"
#include "../../include/Commands/DriveRobot.h"
#include "../../include/Commands/RobotDrive.h"
#include "rev/CANSparkMax.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Drivetrain::Drivetrain() : frc::Subsystem("Drivetrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftMaster.reset(new rev::CANSparkMax(13, rev::CANSparkMax::MotorType::kBrushless));
    leftSlaveOne.reset(new rev::CANSparkMax(1, rev::CANSparkMax::MotorType::kBrushless));
    leftSlaveTwo.reset(new rev::CANSparkMax(2, rev::CANSparkMax::MotorType::kBrushless));
    rightMaster.reset(new rev::CANSparkMax(3, rev::CANSparkMax::MotorType::kBrushless));
    rightSlaveOne.reset(new rev::CANSparkMax(4, rev::CANSparkMax::MotorType::kBrushless));
    rightSlaveTwo.reset(new rev::CANSparkMax(5, rev::CANSparkMax::MotorType::kBrushless));
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void Drivetrain::InitDefaultCommand() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    SetDefaultCommand(new DriveRobot());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Drivetrain::Periodic() {}

void Drivetrain::configMotors() {
    leftSlaveOne->Follow(*leftMaster);
    leftSlaveOne->SetSmartCurrentLimit(40,40,40);
    leftSlaveTwo->Follow(*leftMaster);
    leftSlaveTwo->SetSmartCurrentLimit(40,40,40);
    rightSlaveOne->Follow(*rightMaster);
    rightSlaveOne->SetSmartCurrentLimit(40,40,40);
    rightSlaveTwo->Follow(*rightMaster);
    rightSlaveTwo->SetSmartCurrentLimit(40,40,40);
    rightMaster->SetSmartCurrentLimit(40,40,40);
    leftMaster->SetSmartCurrentLimit(40,40,40);
}

void Drivetrain::setLeftMotor(double power) {
    leftMaster->Set(power);
}

void Drivetrain::setRightMotor(double power) {
    rightMaster->Set(-power);
}

void Drivetrain::resetGoToDistanceState() {
    goToDistanceState = 0;
}
//void Drivetrain::test(double power){
   // rightSlaveTwo->Set(power);
//}

double Drivetrain::getLeftEncoder() {
   return leftMaster->GetEncoder().GetPosition();
}

double Drivetrain::getRightEncoder() {
    return rightMaster->GetEncoder().GetPosition();
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


void Drivetrain::joystickDriveCalculator() {


    // declare motor power and quadrant varialbes
    double leftPower;
    double rightPower;
    int quadrant;

    // get joystick values
    double joyX = Robot::oi->getdriver()->GetX();
    double joyY = -Robot::oi->getdriver()->GetY();

    // calculate radius squared (used in testing for deadzone and in scalling based on the radius)
    double radiusSquared = joyX*joyX + joyY*joyY;

    // used later to store joyV and drive algoritm function output
    double joyV;

    // used in calculating the motor power (adjusts power based on joystick's distance from centre)
    double radiusScaler = (radiusSquared - deadRadiusSquared) / (1.0 - deadRadiusSquared);


    // Check deadzone
    if (radiusSquared <= deadRadiusSquared) {
        setLeftMotor(0);
        setRightMotor(0);
        //frc::SmartDashboard::PutBoolean("deadzone active:", true);
        return;
    }
    //frc::SmartDashboard::PutBoolean("deadzone active:", false);


    // check quadrant and calculate Z
    if (joyY >= 0.0) {

        // quadrant 1
        if (joyX >= 0.0) {
            quadrant = 1;
            joyV = joyY - joyX;
        }

        // quadrant 2
        else {
            quadrant = 2;
            joyV = joyY + joyX;
        }

    } else {

        // quadrant 3
        if (joyX < 0.0) {
            quadrant = 3;
            joyV = -joyY + joyX;
        }

        // quadrant 4
        else {
            quadrant = 4;
            joyV = -joyY - joyX;
        }
    }
    //frc::SmartDashboard::PutNumber("joyV:", joyV);


    // adjusting joyV to reduce sensitivity (using rational function), this is the core math of the algorithm
    joyV = ((turningFxnCoefficient + 1)*(joyV + 1) - turningFxnCoefficient) / (turningFxnCoefficient + joyV + 1) * radiusScaler;


    // set motor power varialbes based on quadrant
    switch (quadrant) {

        // quadrant 1
        case 1:
            leftPower = radiusScaler;
            rightPower = joyV;
            break;

        // quadrant 2
        case 2:
            leftPower = joyV;
            rightPower = radiusScaler;
            break;
        
        // quadrant 3
        case 3:
            //leftPower = -radiusScaler;
            //rightPower = joyV;
            rightPower = joyY - joyX;
            leftPower = joyY + joyX;
            break;
        
        // quadrant 4
        case 4:
            //leftPower = joyV;
            //rightPower = -radiusScaler;
            rightPower = joyY - joyX;
            leftPower = joyY + joyX;
            break;
    }


    // PutNumber() debug statements
    //frc::SmartDashboard::PutNumber("turning function coefficient:", turningFxnCoefficient);

    frc::SmartDashboard::PutNumber("x:", joyX);
    frc::SmartDashboard::PutNumber("y:", joyY);

    frc::SmartDashboard::PutNumber("quadrant:", quadrant);

    frc::SmartDashboard::PutNumber("radius squared:", radiusSquared);
    frc::SmartDashboard::PutNumber("deadzone squared:", deadRadiusSquared);

    frc::SmartDashboard::PutNumber("radius scaler:", radiusScaler);
    frc::SmartDashboard::PutNumber("drive function output:", joyV);

    frc::SmartDashboard::PutNumber("left motor power:", leftPower);
    frc::SmartDashboard::PutNumber("right motor power:", rightPower);
    

    // set motor power
    setLeftMotor(leftPower);
    setRightMotor(rightPower);
}
bool Drivetrain::goToDistance(double rightCentimeters, double leftCentimeters, double power, int rampUpDistance,
			int rampDownDistance, double startingPower, double endingPower) {
		//SmartDashboard.putNumber("Left Wheels Position", getLeftEncoder());
		//SmartDashboard.putNumber("Right Wheels Position", getRightEncoder());

		// --------------------------------------------------------------------------
		// -----------------------Reset variables if
		// necessary-----------------------
		// --------------------------------------------------------------------------

		// If this method is being called for the first time since it last
		// finished, you want to record the initial encoder values
		if (goToDistanceState == 0) {
			goToDistanceState++;
			startingLeftDistance = getLeftEncoder();
			startingRightDistance = getRightEncoder();
			// Robot.logger.info("Drivetrain",
			// "goToDistance starting encoder values are " + getRightEncoder() +
			// ", " + getLeftEncoder());
		}


		// --------------------------------------------------------------------------
		// ---------------------Get target and current
		// distances---------------------
		// --------------------------------------------------------------------------

		// Get target distance in centimeters
		targetLeft = leftCentimeters * encoderClicksPerCentimeter; // used to be
																	// parameters
		targetRight = rightCentimeters * encoderClicksPerCentimeter; // used to
																		// be
																		// parameters
		//System.out.println(
			//	"hi goToDistanceState=" + goToDistanceState + " " + startingLeftDistance + " " + startingRightDistance + " tleft="+targetLeft+" tright="+targetRight);

		// Get the current distance in centimeters
		currentLeft = abs(getLeftEncoder() - startingLeftDistance);
		currentRight = abs(getRightEncoder() - startingRightDistance);
		currentLeftCentimeters = currentLeft / encoderClicksPerCentimeter; // used
																			// to
																			// use
																			// the
																			// parameter
		currentRightCentimeters = currentRight / encoderClicksPerCentimeter; // used
																				// to
																				// use
																				// the
																				// parameter
																				// (same
																				// name)

		// Find the percentage the left and right are to their target
		leftPercentThere = abs(currentLeft / targetLeft);
		rightPercentThere = abs(currentRight / targetRight);
		//System.out.println("Percentages At " + leftPercentThere + ", " + rightPercentThere+" CurrentLeft="+currentLeft+" CurrentRight"+currentRight);
		//System.out.println("Leftcm="+currentLeftCentimeters+" Rightcm="+currentRightCentimeters);

		// Initially set the powers to their default values
		leftMotorMultiplier = 1;
		rightMotorMultiplier = 1;

		// --------------------------------------------------------------------------
		// ----------------Adjust powers if one side has gone
		// farther----------------
		// --------------------------------------------------------------------------

		// Difference between how far the left and right have gone
		powerOffset = GO_TO_DISTANCE_CORRECTION_SPEED * abs(leftPercentThere - rightPercentThere);

		// Only start adjusting the powers once the motors have gone 2 percent
		// of the target distance, to avoid calculation errors
		if (currentRight >= (targetRight * 0.02) && (currentLeft >= (targetLeft * 0.02))) {
			// If the right is closer than the left, increase the left power and
			// decrease the right power
			if (rightPercentThere > (leftPercentThere + 0.001)) {
				leftMotorMultiplier *= 1 + powerOffset;
				rightMotorMultiplier *= 1 - powerOffset;
			}

			// If the left is closer than the right, increase the right power,
			// and decrease the left power
			if ((rightPercentThere + 0.001) < leftPercentThere) {
				leftMotorMultiplier *= 1 - powerOffset;
				rightMotorMultiplier *= 1 + powerOffset;
			}
		}
		//System.out.println("percentages at " + (int)(leftPercentThere * 100) + ", " + (int)(rightPercentThere * 100) + " Power Offset At " + (((int)(1000 * powerOffset)) / 1000.0));
		// --------------------------------------------------------------------------
		// -----------------------Flip the powers if
		// necessary-----------------------
		// --------------------------------------------------------------------------

		// We use the absolute values for setting the powers, so we have to flip
		// the powers based on what direction the robot is going
		if (targetRight < 0) {
			// If the robot is trying to go backwards and has not passed the
			// target
			if (getRightEncoder() - startingRightDistance > targetRight) {
				rightMotorMultiplier *= -1;
			}
		} else {
			// If the robot is trying to go forwards and has passed the target
			if (getRightEncoder() - startingRightDistance > targetRight) {
				rightMotorMultiplier *= -1;
			}
		}

		if (targetLeft < 0) {
			// If the robot is trying to go backwards and has not passed the
			// target
			if (getLeftEncoder() - startingLeftDistance > targetLeft) {
				leftMotorMultiplier *= -1;
			}
		} else {
			// If the robot is trying to go forwards and has passed the target
			if (getLeftEncoder() - startingLeftDistance > targetLeft) {
				leftMotorMultiplier *= -1;
			}
		}

		// --------------------------------------------------------------------------
		// -----------------------------Ramp Down
		// Speeds-----------------------------
		// --------------------------------------------------------------------------

		double rampDownPercentage = 1;
		if (currentRightCentimeters < rampUpDistance) {
			rampDownPercentage = ((currentRightCentimeters / rampUpDistance) * (1 - startingPower)) + startingPower;
			// Robot.logger.info("Drivetrain", "goToDistance ramping down " +
			// (int)(rampDownPercentage * 100) + "%");
		} else if (currentRightCentimeters > abs(rightCentimeters) - rampDownDistance) {
			rampDownPercentage = (((abs(rightCentimeters) - currentRightCentimeters) / rampDownDistance)
					* (1 - endingPower)) + endingPower;
			// Robot.logger.info("Drivetrain", "goToDistance ramping down " +
			// (int)(rampDownPercentage * 100) + "%");
		}

		// Robot.logger.debug("Drivetrain", "goToDistance target is " +
		// rightCentimeters + ", " + leftCentimeters + " current is " +
		// (-(int)((getRightEncoder() - startingRightDistance) /
		// Robot.encoderClicksPerCentimeter())) + ", " +
		// (-(int)((getLeftEncoder() - startingLeftDistance) /
		// Robot.encoderClicksPerCentimeter())));

	//	System.out.println("Left Power = "+leftMotorMultiplier * power * rampDownPercentage+" Right Power = "+rightMotorMultiplier * power * rampDownPercentage);
		setLeftMotor(rightMotorMultiplier * power * rampDownPercentage);
		setRightMotor(leftMotorMultiplier * power * rampDownPercentage);

		// If the left and the right both have gone far enough stop the motors,
		// and reset the goToDistanceState so that the next time
		// the method is called, it will record the starting encoder values
		// again
		if (rightPercentThere >= 1 && leftPercentThere >= 1) {
			setLeftMotor(0);
			setRightMotor(0);
			goToDistanceState = 0;
			// System.out.println("Drivetrain goToDistance at target");
			// System.out.println("Drivetrain goToDistance final encoder values
			// are "+ getRightEncoder() + ", " + getLeftEncoder());
			return true;
		}
		//System.out.println(" return false here...");

		return false;
}
double error = 0;
bool Drivetrain::GyroTurn(double current, double turnAmount, double p, double i, double d){

	static double past = 0;
	static double iValue = 0;
	static int counter = 0;
	// Never go more than 180 degrees in either direction with this function so make sure the step over 360 degrees is
	// handled correctly.  eg at 270 , go to 10 error = 10 - 270 = -260, error should be 370 - 270 = 100 (-260 + 360)
	// eg at 30 go to 300, error = 300 - 30 = 270, error should be 300 - 390 = -90 (270 - 360)
	// so, error of less than -180 needs to be adjusted by +360
	// error of more than +180 is adjusted by -360
	error = turnAmount - current;
	if (error < -180.0)
		error += 360.0;
	if (error > 180.0)
		error -= 360.0;
	double pValue = p*error;
	iValue += i*(error);
	double dValue = d*(past - current);
	double totalValue = pValue + iValue + dValue;

	printf("Gyro: %f  tv = %f\n",current, totalValue);

	if(totalValue > 0.8)
		totalValue = 0.8;
	if(totalValue < -0.8)
		totalValue = -0.8;

	setRightMotor(-totalValue);
	setLeftMotor(totalValue);


	past = current;
	if (std::abs(error) < 1.5) {
		counter++;
	} else {
		counter = 0;
	}
	if(counter >= 10){
		past = 0;
		iValue = 0;
		counter = 0;
		setRightMotor(0);
		setLeftMotor(0);
		return true;
	}
	return false;
}