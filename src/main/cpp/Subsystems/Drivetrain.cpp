// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "../../include/Subsystems/Drivetrain.h"
#include "../../include/Subsystems/lidar.h"
#include "../../include/Subsystems/PathFinder/Path.h"
#include "../../include/Commands/DriveRobot.h"
#include "../../include/Commands/RobotDrive.h"
#include "rev/CANSparkMax.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Drivetrain::Drivetrain() : frc::Subsystem("Drivetrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftMaster.reset(new rev::CANSparkMax(13, rev::CANSparkMax::MotorType::kBrushless));
    leftSlaveOne.reset(new rev::CANSparkMax(1, rev::CANSparkMax::MotorType::kBrushless));
    leftSlaveTwo.reset(new rev::CANSparkMax(2, rev::CANSparkMax::MotorType::kBrushless));
    rightMaster.reset(new rev::CANSparkMax(3, rev::CANSparkMax::MotorType::kBrushless));
    rightSlaveOne.reset(new rev::CANSparkMax(4, rev::CANSparkMax::MotorType::kBrushless));
    rightSlaveTwo.reset(new rev::CANSparkMax(5, rev::CANSparkMax::MotorType::kBrushless));
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    m_Path = new PathFinder(0.02,1,1,1,0.545);
    frc::SmartDashboard::PutNumber("Traverse Right",0);
    frc::SmartDashboard::PutNumber("Traverse Left",0);
}

void Drivetrain::InitDefaultCommand() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    SetDefaultCommand(new DriveRobot());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Drivetrain::Periodic() {
	frc::SmartDashboard::PutNumber("GYRO: ", Robot::ahrs->GetAngle());
	frc::SmartDashboard::PutNumber("Right Distance ", (Robot::drivetrain->getRightEncoder() / 0.2183));
    frc::SmartDashboard::PutNumber("Left Distance ", (Robot::drivetrain->getLeftEncoder() / 0.2183));
    frc::SmartDashboard::PutNumber("Left Speed ", (Robot::drivetrain->getLeftSpeed()));

    

}

void Drivetrain::configMotors() {
    leftSlaveOne->Follow(*leftMaster);
    leftSlaveOne->SetSmartCurrentLimit(40,40,40);
    leftSlaveTwo->Follow(*leftMaster);
    leftSlaveTwo->SetSmartCurrentLimit(40,40,40);
    rightSlaveOne->Follow(*rightMaster);
    rightSlaveOne->SetSmartCurrentLimit(40,40,40);
    rightSlaveTwo->Follow(*rightMaster);
    rightSlaveTwo->SetSmartCurrentLimit(40,40,40);
    rightMaster->SetSmartCurrentLimit(40,40,40);
    leftMaster->SetSmartCurrentLimit(40,40,40);

    rightMaster->GetPIDController().SetP(0.05,0);
    rightMaster->GetPIDController().SetI(0,0);
    rightMaster->GetPIDController().SetD(0,0);

    leftMaster->GetPIDController().SetP(0.05,0);
    leftMaster->GetPIDController().SetI(0,0);
    leftMaster->GetPIDController().SetD(0,0);
}

void Drivetrain::setToCoast() { //set at the end of auto as this is the setup for driving
	rightMaster->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake); //in coast (or driver mode) the master should be on brake
	rightSlaveOne->SetIdleMode(rev::CANSparkMax::IdleMode::kCoast);
	rightSlaveTwo->SetIdleMode(rev::CANSparkMax::IdleMode::kCoast);

	leftMaster->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake); //same as above comment
	leftSlaveOne->SetIdleMode(rev::CANSparkMax::IdleMode::kCoast);
	leftSlaveTwo->SetIdleMode(rev::CANSparkMax::IdleMode::kCoast);
}

void Drivetrain::setToBrake() { //called at the beginning of autonomous
	rightMaster->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
	rightSlaveOne->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
	rightSlaveTwo->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);

	leftMaster->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
	leftSlaveOne->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
	leftSlaveTwo->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
}

void Drivetrain::setLeftMotor(double power) {
    leftMaster->Set(power);
}

void Drivetrain::setRightMotor(double power) {
    rightMaster->Set(-power);
}

void Drivetrain::setLeftPosition(double encoder) {
    leftMaster->GetPIDController().SetReference(encoder,rev::ControlType::kPosition);
}

void Drivetrain::setRightPosition(double encoder) {
    rightMaster->GetPIDController().SetReference(encoder, rev::ControlType::kPosition);
}

void Drivetrain::resetGoToDistanceState() {
    goToDistanceState = 0;
}
//void Drivetrain::test(double power){
   // rightSlaveTwo->Set(power);
//}

double Drivetrain::getLeftEncoder() {
   return leftMaster->GetEncoder().GetPosition();
}

double Drivetrain::getRightEncoder() {
    return rightMaster->GetEncoder().GetPosition();
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


void Drivetrain::joystickDriveCalculator() {


    // declare motor power and quadrant varialbes
    double leftPower;
    double rightPower;
    int quadrant;

    // get joystick values
    double joyX = Robot::oi->getdriver()->GetX();
    double joyY = -Robot::oi->getdriver()->GetY();

    // calculate radius squared (used in testing for deadzone and in scalling based on the radius)
    double radiusSquared = joyX*joyX + joyY*joyY;

    // used later to store joyV and drive algoritm function output
    double joyV;

    // used in calculating the motor power (adjusts power based on joystick's distance from centre)
    double radiusScaler = (radiusSquared - deadRadiusSquared) / (1.0 - deadRadiusSquared);


    // Check deadzone
    if (radiusSquared <= deadRadiusSquared) {
        setLeftMotor(0);
        setRightMotor(0);
        //frc::SmartDashboard::PutBoolean("deadzone active:", true);
        return;
    }
    //frc::SmartDashboard::PutBoolean("deadzone active:", false);


    // check quadrant and calculate Z
    if (joyY >= 0.0) {

        // quadrant 1
        if (joyX >= 0.0) {
            quadrant = 1;
            joyV = joyY - joyX;
        }

        // quadrant 2
        else {
            quadrant = 2;
            joyV = joyY + joyX;
        }

    } else {

        // quadrant 3
        if (joyX < 0.0) {
            quadrant = 3;
            joyV = -joyY + joyX;
        }

        // quadrant 4
        else {
            quadrant = 4;
            joyV = -joyY - joyX;
        }
    }
    //frc::SmartDashboard::PutNumber("joyV:", joyV);


    // adjusting joyV to reduce sensitivity (using rational function), this is the core math of the algorithm
    joyV = ((turningFxnCoefficient + 1)*(joyV + 1) - turningFxnCoefficient) / (turningFxnCoefficient + joyV + 1) * radiusScaler;


    // set motor power varialbes based on quadrant
    switch (quadrant) {

        // quadrant 1
        case 1:
            leftPower = radiusScaler;
            rightPower = joyV;
            break;

        // quadrant 2
        case 2:
            leftPower = joyV;
            rightPower = radiusScaler;
            break;
        
        // quadrant 3
        case 3:
            //leftPower = -radiusScaler;
            //rightPower = joyV;
            rightPower = joyY - joyX;
            leftPower = joyY + joyX;
            break;
        
        // quadrant 4
        case 4:
            //leftPower = joyV;
            //rightPower = -radiusScaler;
            rightPower = joyY - joyX;
            leftPower = joyY + joyX;
            break;
    }


    // PutNumber() debug statements
    //frc::SmartDashboard::PutNumber("turning function coefficient:", turningFxnCoefficient);

    frc::SmartDashboard::PutNumber("x:", joyX);
    frc::SmartDashboard::PutNumber("y:", joyY);

    frc::SmartDashboard::PutNumber("quadrant:", quadrant);

    frc::SmartDashboard::PutNumber("radius squared:", radiusSquared);
    frc::SmartDashboard::PutNumber("deadzone squared:", deadRadiusSquared);

    frc::SmartDashboard::PutNumber("radius scaler:", radiusScaler);
    frc::SmartDashboard::PutNumber("drive function output:", joyV);

    frc::SmartDashboard::PutNumber("left motor power:", leftPower);
    frc::SmartDashboard::PutNumber("right motor power:", rightPower);
    

    // set motor power
    setLeftMotor(leftPower);
    setRightMotor(rightPower);
}

double  Drivetrain::percentDone()  const  {
	// Minimum value is 0
	if (leftPercentThere <= 0.0 && rightPercentThere <= 0.0) {
		return 0.0;
	}

	//  Maximum value is 1.0
	if (leftPercentThere >= 1.0 && rightPercentThere >= 1.0) {
		return 1.0;
	} 

    // Return the max of the two values
    return (leftPercentThere > rightPercentThere) ? leftPercentThere : rightPercentThere;
}

int countGoToDist = 0;
bool Drivetrain::goToDistance(double rightCentimeters, double leftCentimeters, double power, int rampUpDistance,
			int rampDownDistance, double startingPower, double endingPower) {
		//SmartDashboard.putNumber("Left Wheels Position", getLeftEncoder());
		//SmartDashboard.putNumber("Right Wheels Position", getRightEncoder());

		// --------------------------------------------------------------------------
		// -----------------------Reset variables if
		// necessary-----------------------
		// --------------------------------------------------------------------------

		// If this method is being called for the first time since it last
		// finished, you want to record the initial encoder values
		if (goToDistanceState == 0) {
			goToDistanceState++;
			startingLeftDistance = getLeftEncoder();
			startingRightDistance = getRightEncoder();
			// Robot.logger.info("Drivetrain",
			// "goToDistance starting encoder values are " + getRightEncoder() +
			// ", " + getLeftEncoder());
		}


		// --------------------------------------------------------------------------
		// ---------------------Get target and current
		// distances---------------------
		// --------------------------------------------------------------------------

		// Get target distance in centimeters
		targetLeft = leftCentimeters * encoderClicksPerCentimeter; // used to be
																	// parameters
		targetRight = rightCentimeters * encoderClicksPerCentimeter; // used to
																		// be
																		// parameters
		//System.out.println(
			//	"hi goToDistanceState=" + goToDistanceState + " " + startingLeftDistance + " " + startingRightDistance + " tleft="+targetLeft+" tright="+targetRight);

		// Get the current distance in centimeters
		currentLeft = fabs(getLeftEncoder() - startingLeftDistance);
		currentRight = fabs(getRightEncoder() - startingRightDistance);
		currentLeftCentimeters = currentLeft / encoderClicksPerCentimeter; // used
																			// to
																			// use
																			// the
																			// parameter
		currentRightCentimeters = currentRight / encoderClicksPerCentimeter; // used
																				// to
																				// use
																				// the
																				// parameter
																				// (same
																				// name)

		// Find the percentage the left and right are to their target
		leftPercentThere = fabs(currentLeft / targetLeft);
		rightPercentThere = fabs(currentRight / targetRight);
		//System.out.println("Percentages At " + leftPercentThere + ", " + rightPercentThere+" CurrentLeft="+currentLeft+" CurrentRight"+currentRight);
		//System.out.println("Leftcm="+currentLeftCentimeters+" Rightcm="+currentRightCentimeters);

		// Initially set the powers to their default values
		leftMotorMultiplier = 1;
		rightMotorMultiplier = 1;

		// --------------------------------------------------------------------------
		// ----------------Adjust powers if one side has gone
		// farther----------------
		// --------------------------------------------------------------------------

		// Difference between how far the left and right have gone
		powerOffset = GO_TO_DISTANCE_CORRECTION_SPEED * fabs(leftPercentThere - rightPercentThere);

		// Only start adjusting the powers once the motors have gone 2 percent
		// of the target distance, to avoid calculation errors
		if (currentRight >= (targetRight * 0.02) && (currentLeft >= (targetLeft * 0.02))) {
			// If the right is closer than the left, increase the left power and
			// decrease the right power
			if (rightPercentThere > (leftPercentThere + 0.001)) {
				leftMotorMultiplier *= 1 + powerOffset;
				rightMotorMultiplier *= 1 - powerOffset;
			}

			// If the left is closer than the right, increase the right power,
			// and decrease the left power
			if ((rightPercentThere + 0.001) < leftPercentThere) {
				leftMotorMultiplier *= 1 - powerOffset;
				rightMotorMultiplier *= 1 + powerOffset;
			}
		}
		//System.out.println("percentages at " + (int)(leftPercentThere * 100) + ", " + (int)(rightPercentThere * 100) + " Power Offset At " + (((int)(1000 * powerOffset)) / 1000.0));
		// --------------------------------------------------------------------------
		// -----------------------Flip the powers if
		// necessary-----------------------
		// --------------------------------------------------------------------------

		// We use the absolute values for setting the powers, so we have to flip
		// the powers based on what direction the robot is going
		if (targetRight < 0) {
			// If the robot is trying to go backwards and has not passed the
			// target
			if (getRightEncoder() - startingRightDistance > targetRight) {
				rightMotorMultiplier *= -1;
			}
		} else {
			// If the robot is trying to go forwards and has passed the target
			if (getRightEncoder() - startingRightDistance > targetRight) {
				rightMotorMultiplier *= -1;
			}
		}

		if (targetLeft < 0) {
			// If the robot is trying to go backwards and has not passed the
			// target
			if (getLeftEncoder() - startingLeftDistance > targetLeft) {
				leftMotorMultiplier *= -1;
			}
		} else {
			// If the robot is trying to go forwards and has passed the target
			if (getLeftEncoder() - startingLeftDistance > targetLeft) {
				leftMotorMultiplier *= -1;
			}
		}

		// --------------------------------------------------------------------------
		// -----------------------------Ramp Down
		// Speeds-----------------------------
		// --------------------------------------------------------------------------

		double rampDownPercentage = 1;
		if (currentRightCentimeters < rampUpDistance) {
			rampDownPercentage = ((currentRightCentimeters / rampUpDistance) * (1 - startingPower)) + startingPower;
			// Robot.logger.info("Drivetrain", "goToDistance ramping down " +
			// (int)(rampDownPercentage * 100) + "%");
		} else if (currentRightCentimeters > fabs(rightCentimeters) - rampDownDistance) {
			rampDownPercentage = (((fabs(rightCentimeters) - currentRightCentimeters) / rampDownDistance)
					* (1 - endingPower)) + endingPower;
			// Robot.logger.info("Drivetrain", "goToDistance ramping down " +
			// (int)(rampDownPercentage * 100) + "%");
		}

		// Robot.logger.debug("Drivetrain", "goToDistance target is " +
		// rightCentimeters + ", " + leftCentimeters + " current is " +
		// (-(int)((getRightEncoder() - startingRightDistance) /
		// Robot.encoderClicksPerCentimeter())) + ", " +
		// (-(int)((getLeftEncoder() - startingLeftDistance) /
		// Robot.encoderClicksPerCentimeter())));

	//	System.out.println("Left Power = "+leftMotorMultiplier * power * rampDownPercentage+" Right Power = "+rightMotorMultiplier * power * rampDownPercentage);
		//printf("\nRight=%f | Left=%f | RTarget=%f | LTarget=%f",(rightMotorMultiplier * power * rampDownPercentage),(leftMotorMultiplier * power * rampDownPercentage),targetRight,targetLeft);
		setRightMotor(rightMotorMultiplier * power * rampDownPercentage);
		setLeftMotor(leftMotorMultiplier * power * rampDownPercentage);

		// If the left and the right both have gone far enough stop the motors,
		// and reset the goToDistanceState so that the next time
		// the method is called, it will record the starting encoder values
		// again
		if (rightPercentThere >= 1 && leftPercentThere >= 1) {
			setLeftMotor(0);
			setRightMotor(0);
			goToDistanceState = 0;
			// System.out.println("Drivetrain goToDistance at target");
			// System.out.println("Drivetrain goToDistance final encoder values
			// are "+ getRightEncoder() + ", " + getLeftEncoder());
			return true;
			
		} 
		//System.out.println(" return false here...");

		return false;
}
double error = 0;
bool Drivetrain::GyroTurn(double current, double turnAmount, double p, double i, double d){
	static double past = 0;
	static double iValue = 0;
	static int counter = 0;
	// Never go more than 180 degrees in either direction with this function so make sure the step over 360 degrees is
	// handled correctly.  eg at 270 , go to 10 error = 10 - 270 = -260, error should be 370 - 270 = 100 (-260 + 360)
	// eg at 30 go to 300, error = 300 - 30 = 270, error should be 300 - 390 = -90 (270 - 360)
	// so, error of less than -180 needs to be adjusted by +360
	// error of more than +180 is adjusted by -360
	error = turnAmount - current;
	if (error < -180.0)
		error += 360.0;
	if (error > 180.0)
		error -= 360.0;
	double pValue = p*error;
	iValue += i*(error);
	double dValue = d*(past - current);
	double totalValue = pValue + iValue + dValue;

	printf("Gyro: %f  tv = %f\n",current, totalValue);

	if(totalValue > 0.8)
		totalValue = 0.8;
	if(totalValue < -0.8)
		totalValue = -0.8;
	totalValue *= 0.30;
	setRightMotor(-totalValue);
	setLeftMotor(totalValue);


	past = current;
	if ((std::abs(error) < 1.5)||((fabs(totalValue) < 0.1)&&(fabs(error) < 8))) {
		counter++;
	} else {
		counter = 0;
	}
	if(counter >= 10){
		past = 0;
		iValue = 0;
		counter = 0;
		setRightMotor(0);
		setLeftMotor(0);
		return true;
	}
	return false;
}


void Drivetrain::initAutoScore() {
	as_m_case = 0;
	as_move1 = false;
	as_m_SubCase = 0;
	as_mode = 0; 
    mgb_state = 0;
}

enum { // Cases for autoScore
    autoScoreInit,
    autoScoreReadLidar1,
    autoScoreExamineLidar,
    autoScoreFindLoadStation,
    autoScoreFoundLoadStation,
    autoScoreHavePath,
    autoScorePathComplete,
    autoScoreScanForWaist,
    autoScoreLidarForWaist,
    autoScoreWaistHasMoved,
    autoScoreReadyForPickPlace,
    autoScorePickPlaceComplete,
    autoScoreRocketFound,
};

// autoScore - Next Steps:
// 1. If Initial scan shows we're close enough that everything can be done with the arm (no drive base movement)
// then set up for waist scans and proceed to autoScorePathComplete
// 1.5 Look at speeding things up.  Maybe look at path code to see if we can increase speed and/or
// acceleration.  Initial test messed up the overal distance.  May just need to ensure we leave
// motor command as go to position instead of a power of 0 in which case some coasting will take place
// can easily do a power level of 0 a bit later in the process to ensure they're ready for normal
// drivetrain operation.
// 2. Modify how far arm pushes forward based on distance reading.  Right now, it just moves to a fixed
// position.  We should be able to push forward 2" further with the hatch clamp than with the cargo holder.
// 3. Implement code to find rocket - similar to finding hatch panel indent but will need to accommodate
// situation where rocket has a hatch on it and it's placed low.  Gap will not necessarily have a backing to
// it so we won't find a useable line at the back of the gap.  Scoring on rocket will need to work for
// low, med and high levels.  For Med and High, robot can (and should) be positioned closer to the rocket
// than is possible for low scoring.
// 4. Consider auto scoring of cargo.
// 5. Consider auto pickup of cargo.

// If we have more trouble with the path generation, here's the distance - based algorithm:
//         ------------------------------------
//        / |                                 |\
//       /  |                                 | \
//      /   |                                 |  \
//     /    |                                 |   \
//    t0   t1                                t2   t3
//    <-d1-> <-------------- d2 ------------> <-d3->
//  Also given acceleration a, total distance required dReq, max velocity vMax and cycleTime (1/50.0)
// t1 = Vmax / a
// d1 = 0.5 * a * t1^2, d3 = d1
// if (2 * d1 > dReq) // No cruise is reached, purely accel then decel
//     d1 = dReq / 2, d2 = 0, d3 = d1
//     t1 = sqrt(2 * d1 / a), t2 = t1, t3 = t2 + t1
// else // we have a cruise section
//     d2 = dReq - 2 * d1
//     t2 = t1 + d2 / vMax
//     t3 = t2 + t1
// to generate the path ...
// for(double tcnt = 0;tcnt < t3;tcnt += cycleTime)
//     if (tcnt < t1)
//         d = 0.5 * a * tcnt * tcnt
//     else if (tcnt < t2)
//         d = d1 + vMax * (tcnt - t1)
//     else if (tcnt < t3)
//         d = d1 + d2 + d3 - 0.5 * a * (t3 - tcnt) * (t3 - tcnt)
// 
// d = d1 + d2 + d3 // should be our final position calculation.
// 

//Returns   0->not finished yet
//          1->Finished
//          2->Failed to find target
//          3->Failed to find target after driving forwards
//Parameter: autoType
//          0 -> human player pickup / cargoship dropoff
//          1 -> Rocket low level
//          2 -> Rocket medium level
//          3 -> Rocket high level
int Drivetrain::autoScore(int autoType) {
    double dirX,dirY,mag,scoringAngle2,targetAngle;
    bool srch_result,as_move_result;
    double tarX,tarY,tarAngle,tarDist;

	switch (as_m_case) {
        case  autoScoreInit:
            Robot::manipulatorArm->m_CurrentPosition = 0;

            as_search_mode = 0;
            if(autoType == 0)
                as_move1 = Robot::manipulatorArm->moveToXY(17.0,22.0,-182.0,0,20.0); //*** Practice Bot ***
            else {//For rocket we can start in carry
                as_move1 = true;
                as_search_mode = 1;
            }

            if(Robot::manipulatorArm->ifHatch())
                as_mode = 0; // We have a hatch.  We want to place it.
            else
                as_mode = 2; // We do not have a hatch.  We want to retrieve one.

            if(as_move1){
                as_m_case = autoScoreReadLidar1; // Move on to case where we read lidar for drivebase approach.
                as_lidarScanCount = 0;
			}
            break;
        case autoScoreReadLidar1:
            Robot::lidar->readLidar();
            as_m_case = autoScoreExamineLidar;
            break;
        case autoScoreExamineLidar:
            if(Robot::lidar->readComplete()) {
                as_m_case = autoScoreReadLidar1;
                if(autoType == 0){
                    if(Robot::lidar->findLoadStation(60))
                        as_m_case = autoScoreFoundLoadStation;
                }
                else{
                    if(Robot::lidar->findRocket_Lines())
                        as_m_case = autoScoreRocketFound;
                }
            }
            break; 
        case autoScoreFoundLoadStation:
            {
            as_lidarScanCount = 0;
            double max_vel = 3; //m/s
            double max_acc = 4; //m/s^2
            double cycle_time = 1.0/50.0;
            double wheelbase = 0.545;
            //We have the location
            if (as_search_mode == 0) // Cargo / human player station.
                {
                //as_angle = Robot::lidar->m_ScoringFinal.angle - 180;
                as_distance = Robot::lidar->m_ScoringFinal.dist;
                //as_ang = Robot::lidar->m_targetAngle;

                tarX = Robot::lidar->m_targetScoring.x;
                tarY = Robot::lidar->m_targetScoring.y;// + 100;
                }
            else if (as_search_mode == 1) // Rocket - get data from FindRocket.
                {
                tarX = targY; // Code below doesn't use angle or distance stuff.
                tarY = targX; // need to swap X and Y.  Y is lateral, X is distance away.
                as_distance = sqrt(tarX*tarX + tarY*tarY);
                }

            printf("\nTarX = %f | TarY = %f | ang=%f",tarX,tarY,as_ang);

            //Calculate radius
            double r = 0;
            double arc_angle, dist;
            if(tarX != 0) {
                r = fabs((tarX*tarX) / (2 * tarY) + (tarY / 2));
                if ((r - fabs(tarY)*1.25 < 0)||(r == fabs(tarY))) // This is an error condition.  fabs(tarY) is expected to be 
                    { // quite a bit less than r.  If equal bail as well.  Leads to div 0 errors below.
                    as_m_case = autoScoreReadLidar1; // go back to reading Lidar.  Current reading is a problem.
                    break;
                    }
                //Waist calculation
                //  Direction vector center of circle to target
                double dir_angle = atan((tarX) / (r - fabs(tarY))) * 180 / M_PI;
                //  angle calculation of the direction vector perpenticular to previous direction
                if(tarY > 0)
                    dir_angle *= -1;
                as_ang = (dir_angle + Robot::lidar->m_ScoringAngle2 + Robot::lidar->m_targetAngle);
                printf("\nr = %f | ANGLES: target = %f | direction = %f | Scoring = %f",r,Robot::lidar->m_targetAngle,dir_angle, Robot::lidar->m_ScoringAngle2);
                as_ang -= 2;
                as_ang *= -1;
                //if(as_ang > 60) {
                //    printf("Waist angle greater then 60! %f",as_ang);
                //    as_m_case = 1;
                //    return true;
                //}
                //Distance calculation
                arc_angle = atan(tarX / (r - fabs(tarY)));
                if((r - tarY) < 0)
                    arc_angle = M_PI - arc_angle;
                dist = r * arc_angle;
                if(tarY > 0) { //Left wheel will turn more
                    kl = 1 + ((545.0 / 2) / r);
                    kr = 1 - ((545.0 / 2) / r);
                    //as_ang *= -1;
                }
                else {
                    kr = 1 + ((545.0 / 2) / r);
                    kl = 1 - ((545.0 / 2) / r);
                    //as_ang *= -1;
                }
                printf("\nRadius = %f Gains = %f | %f Angle = %f | dist = %f",r,kr,kl,as_ang,dist);
            }
            else { //Drive striaght
                dist = as_distance;
                kr = 1;
                kl = 1;
            }
            
            //Movement calculations
            dist /= 1000;
            double t1 = max_vel / max_acc, t2, t3;
            double d1 = 0.5 * max_acc * (t1*t1), d2, d3 = d1;
            if(2*d1 > dist) { //No cruise
                d1 = dist / 2;
                d2 = 0;
                d3 = d1;
                t1 = sqrt(2 * d1 / max_acc);
                t2 = t1;
                t3 = t2 + t1;
            }
            else {
                d2 = dist - 2 * d1;
                t2 = t1 + d2 / max_vel;
                t3 = t2 + t1;
            }
            printf("\nPath: t1=%f, t2=%f, t3=%f | d1=%f, d2=%f, d3=%f | max_acc=%f | ",t1,t2,t3,d1,d2,d3,max_acc);

            //Path generation
            d[0] = 0;
            int i=0;
            
            for(double tcnt = 0;tcnt<t3;tcnt += cycle_time,i++) {
                if(tcnt < t1)
                    d[i] = 0.5 * max_acc * (tcnt*tcnt);
                else if(tcnt < t2)
                    d[i] = d1 + (max_vel * (tcnt-t1));
                else if(tcnt < t3)
                    d[i] = d1+d2+d3 - (0.5 * max_acc * ((t3-tcnt)*(t3-tcnt)));
            }
            d[i++] = d1+d2+d3;
            mtime = i;
            printf("Elements = %i",i);
            traverseCnt = 0;
            as_m_case = autoScoreHavePath;
            encPrevLeft = getLeftEncoder();
            encPrevRight = getRightEncoder();
            as_prevWaist = Robot::manipulatorArm->getWaistAngle();
            }
			
            break;
        case autoScoreHavePath:
            {
            
            if(traverseCnt >= mtime) {
                //return true;
                as_m_case = autoScorePathComplete;
                Robot::lidar->readLidar(); // Reset lidar indicator so we get a fresh scan.
                as_lidarScanCount = 0; // Keep track of how many times we try to scan.
                as_cnt = 0;
                //return true;
                //Waist should be here, but just to make sure
                as_m_SubCase = 1;
                setLeftMotor(0);
                setRightMotor(0);
            }
            else {
                //Waist Movement
                //Robot::manipulatorArm->moveWaist(as_prevWaist + as_waist_incr);
                as_prevWaist += as_waist_incr;
                //Main path velocity
                double distance = d[traverseCnt];
                double enDist = (distance * 20.81); //velocity is per second not per cycle
                //left wheel
                encLeft = enDist * kl + encPrevLeft;
                encRight = -(enDist * kr) + encPrevRight;
                
                printf("\nCnt = %i | dist = %f | EncLeft = %f EncRight = %f | waist = %f",traverseCnt, distance, encLeft,encRight,as_prevWaist + as_waist_incr);
                setLeftPosition(encLeft);
                setRightPosition(encRight);

                //encPrevRight = encRight;
                //encPrevLeft = encLeft;
                traverseCnt++;
            }
            }
            break;
        case autoScorePathComplete:
            if(as_cnt > 25)
                as_m_case = autoScoreScanForWaist;
            as_cnt++;
            break;
        case autoScoreScanForWaist: // Path is complete.  Need to scan lidar for lines that gives us our waist target.
            if(Robot::lidar->readComplete())  // Once this lidar scan is complete, process it.
                {
                as_lidarScanCount++;
                if (as_lidarScanCount > 3)
                    { // Too many re-tries.  Not getting anything.  Time to cancel
                    return 3;
                    }
                else
                    {
                    as_m_case = autoScoreLidarForWaist;
                    }                
                }
            break;
        case autoScoreLidarForWaist: {
            //Recalculate waist angle and move it there, to ensure we are pointed the right direction
            if (as_search_mode == 0)
                srch_result = Robot::lidar->findLoadStation_Lines(-as_ang);
            else
                srch_result = Robot::lidar->findRocket_Lines(); // We're looking for rockets.
            if (!srch_result)
                {
                //If not found repeat the scan up to 3 times.
                Robot::lidar->readLidar(); // Reset lidar indicator so we get a fresh scan.
                as_m_case = autoScorePathComplete; // check scan again.  Do this up to 3 times.
                }
            else // Scan is good.  Figure out how much to turn the waist.
                {        
                if (as_search_mode == 0)
                    {
                    tarAngle = Robot::lidar->m_ScoreLineAngle;
                    tarX = Robot::lidar->m_ScoringLinePoint.x;
                    tarY = Robot::lidar->m_ScoringLinePoint.y;
                    tarDist = Robot::lidar->m_ScoringLineDist;
                    }
                else // Looking for a rocket.
                    {
                    tarX = Robot::lidar->m_ScoringLinePoint.y; // For waist, use m_ScoringLinePoint,
                    tarY = Robot::lidar->m_ScoringLinePoint.x; // not tarX, tarY.  They're not set to anything.
                    //tarX = targY; // Code below doesn't use angle or distance stuff.
                    //tarY = targX; // need to swap X and Y.  Y is lateral, X is distance away.
                    tarDist = sqrt(tarX*tarX+tarY*tarY);
                    if (tarX != 0)
                        tarAngle = atan((double)tarY / (double)tarX) * 180 / M_PI; // Angle from Lidar to Target.
                    else
                        tarAngle = 90;                    
                    }
                distFromWaist = sqrt((tarDist*tarDist)+(289.3*289.3)-2*(tarDist)*(289.3)*cos((180-tarAngle) * M_PI/180));
                printf("\nTarX = %f | TarY = %f | ang=%f | distFromWaist=%f\n",tarX,tarY,tarAngle,distFromWaist);
                if (distFromWaist != 0)
                    {
                    waistAngle = -asin((tarDist*sin((180-tarAngle) * M_PI/180))/(distFromWaist)) * 180 / M_PI;
                    if ((waistAngle > -65.0)&&(waistAngle <= 65.0)) // Only proceed with valid angles.
                        {
                        printf("\nWaist: tarAng=%f | x=%f | y=%f | TarDist=%f || wDist=%f | wAngle=%f",tarAngle,tarX,tarY,tarDist,distFromWaist,waistAngle);
                        as_ang = waistAngle;// + 2.0;
                        Robot::manipulatorArm->moveWaist(waistAngle);
                        if (fabs(waistAngle) > 15.0) // Build in a delay if we need to turn the waist rather far (more than 15 deg)
                            as_cnt = (fabs(waistAngle) - 15); // Give us 50 counts for every 50 degrees -> 50 degrees per second.
                        else
                            as_cnt = 0; // No need to wait for angles less than 15.                
                        as_m_case = autoScoreWaistHasMoved; // Carry on to next state.
                        //as_m_case = 99; // Stop at special case 99.
                        }
                    else // Unable to calculate a valid angle.
                        {
                        Robot::lidar->readLidar(); // Reset lidar indicator so we get a fresh scan.
                        as_m_case = autoScorePathComplete; // check scan again.  Do this up to 3 times.
                        }
                    }
                else // distFromWaist gives non-calculatable angle.  Re-do.
                    {
                    Robot::lidar->readLidar(); // Reset lidar indicator so we get a fresh scan.
                    as_m_case = autoScorePathComplete; // check scan again.  Do this up to 3 times.
                    }
                }
            }
            break;
        case autoScoreWaistHasMoved:
            if (as_cnt > 0)
                as_cnt--;
            else // as_cnt is at 0, no need to wait any longer.
            {   
    //            if (Robot::manipulatorArm->moveToXY(25.5,20.0,-182.0,as_ang,20.0)){ //25.5,25.0,-182.0,as_angle,20.0
                if (as_search_mode == 0) // cargo ship and loading station
                    as_move_result = Robot::manipulatorArm->moveToXY(23.17,19.5,-195.5,as_ang,20.0);
                else // Scoring on rocket.  Can be low, med, high based on as_rocket_score_level
                    { // distFromWaist is typically 823mm = 32.4".  So start 10" back and move to 6" back.
                    if (distFromWaist / 25.4 < 46.0)
                        {
                        if (autoType == 1)
                            as_move_result = Robot::manipulatorArm->moveToXY(distFromWaist/25.4 - 12.0,19.5,-185.0,as_ang,20.0);
                        else if (autoType == 2)
                            as_move_result = Robot::manipulatorArm->moveToXY(distFromWaist/25.4 - 14.0,48.0,-195.5,as_ang,20.0);
                        else if (autoType == 3)
                            as_move_result = Robot::manipulatorArm->moveToXY(distFromWaist/25.4 - 16.0,75.0,-195.5,as_ang,20.0);                    
                        }
                    else  // trying to reach out way to far.  Cancel this one.
                        {
                        as_m_case = autoScoreReadLidar1; // This lidar readings is trying to make arm
                        break; // move out way too far.  Cancel.
                        }
                    }
                

                if (as_move_result){ // ** Practice Bot **
                    as_m_case = autoScoreReadyForPickPlace;
                    as_cnt = 0;
                    if(as_mode == 0)
                        Robot::manipulatorArm->releaseHatch();
                    else if(as_mode == 1)
                        Robot::manipulatorArm->intakeWheelsSpin(1);
                }
            }
            break;
        case autoScoreReadyForPickPlace: // Move forward to pick or place the piece.
            if (as_search_mode == 0)
                as_move_result = Robot::manipulatorArm->moveToXY(27.17,19.5,-195.5,as_ang,20.0);
            else
                {
                if (autoType == 1)
                    as_move_result = Robot::manipulatorArm->moveToXY(distFromWaist/25.4 - 7.5,19.5,-185.0,as_ang,20.0);
                else if (autoType == 2)
                    as_move_result = Robot::manipulatorArm->moveToXY(distFromWaist/25.4 - 7.5,48.0,-195.5,as_ang,20.0);
                else if (autoType == 3)
                    as_move_result = Robot::manipulatorArm->moveToXY(distFromWaist/25.4 - 7.5,75.0,-195.5,as_ang,20.0);                    
                }
            
            if (as_move_result) 
                {
                if((as_mode == 1) || (as_mode == 0)) {
                    as_cnt++;
                    if(as_cnt == 30) // After moving arm forward, wait to ensure hatch is released.
                        as_m_case = autoScorePickPlaceComplete;
                }
                else 
                    {
                    if(Robot::manipulatorArm->ifHatch() || Robot::manipulatorArm->ifCargo())
                        {
                        as_m_case = autoScorePickPlaceComplete;
                        }
                    }
                }
            break;
        case autoScorePickPlaceComplete:
//            if (Robot::manipulatorArm->moveToXY(20.0,20.0,-182.0,as_ang,20.0)){
            if (as_search_mode == 0)
                as_move_result = Robot::manipulatorArm->moveToXY(20.0,20.0,-187.0,as_ang,20.0);
            else
                {
                if (autoType == 1)
                    as_move_result = Robot::manipulatorArm->moveToXY(15.0,20.0,-187.0,as_ang,20.0);
                else if (autoType == 2)
                    as_move_result = Robot::manipulatorArm->moveToXY(15.0,48.0,-187.5,as_ang,20.0);
                else if (autoType == 3)
                    as_move_result = Robot::manipulatorArm->moveToXY(15.0,75.0,-187.5,as_ang,20.0);                    
                }
            
            if (as_move_result){ // *** Practice Bot ***
                as_m_case = autoScoreInit; // Ready for next time.
                Robot::manipulatorArm->grabHatch();
                Robot::manipulatorArm->intakeWheelsSpin(0);
				return 1;
            }
            break;
        case autoScoreRocketFound: // Rocket has been found.  Calculate target score point.
            // Target is point 508mm closer to robot than the midpoint of m_RocketTarget
            //calculate target
            //	vector math. Calculate the direction vector of the midpoint perpenticular to
            //	the vector between pnt1 and pnt2
            // Need to implement code to determine if we're close enough to a target to just
            // go score instead of moving the drive base at all.
            // Rocket targets seem to be off by about 2" to the right on both sides.
            // This could be due to the way that the lidar rotates and how we're picking up
            // line end points.  How best to adjust for this?
            // Easiest is to shift the Y value by 50mm or so.  This is ok when straight on but
            // can mess things up when there's a substantial angle to it.
            // Could rotate things (32" out from waist, 2" rotation is 3.5 degrees)
            // This could most-easily be done during the lidar read for rocket target detection
            // 

            dirX = Robot::lidar->m_RocketTarget.end.y - Robot::lidar->m_RocketTarget.start.y ;//pnt2Y - pnt1Y;
            dirY = -(Robot::lidar->m_RocketTarget.end.x - Robot::lidar->m_RocketTarget.start.x) ;//pnt2Y - pnt1Y;
            //	Convert to unit vector
            mag = sqrt((dirX * dirX)+(dirY * dirY));
            dirX /= mag;
            dirY /= mag;
            //	calculate target position
            targX = (508 * dirX) + ((Robot::lidar->m_RocketTarget.end.x + Robot::lidar->m_RocketTarget.start.x) / 2);
            targY = (508 * dirY) + ((Robot::lidar->m_RocketTarget.end.y + Robot::lidar->m_RocketTarget.start.y) / 2);
            if (targX != 0)
                scoringAngle2 = atan(((double)targY) / ((double)targX)) * 180 / M_PI;
            else
                scoringAngle2 = 90;
            if (dirX != 0)							
                targetAngle = atan(dirY / dirX) * 180 / M_PI;
            else
                targetAngle = 90;
            printf("Rocket Move To = (%d,%d)\n",targX,targY);
            as_search_mode = 1; // Rocket, not cargo.  Return to autoScoreCloseRocket when movment complete.
            as_rocket_score_level = 2; // 0=low, 1=mid, 2=high
            as_m_case = autoScoreFoundLoadStation;
            break;
        case 99: // Special case used to halt further motion ** Testing Only **
            break;
    }
	return 0;
}

double Drivetrain::getLeftSpeed() {
    return leftMaster->GetEncoder().GetVelocity();
}

bool Drivetrain::getNearestBall() {
    switch (mgb_state)  {
        case 0:
            if((Robot::manipulatorArm->ifHatch())||(Robot::manipulatorArm->ifCargo())) {
                return true;
            }
            Robot::manipulatorArm->setInCargoPosition();
            Robot::manipulatorArm->m_CurrentPosition = 5;

            mgb_polarBallPt.angle = 0.0;
            mgb_polarBallPt.dist  = 0;

            mgb_cartX = 0;
            mgb_cartY = 0;
            mgb_angle = 0.0;
            mgb_scanCnt = 0;
            //The idea here is to move the arm into a position where the waist can move freely
            //  and the end effector doesn't interfer with the lidar.
            mgb_Move1 = Robot::manipulatorArm->moveToXY(18.0,27.5,-60.0,0,35.0); // Move to X,Y co-ords
            if(mgb_Move1)
                mgb_state = 1;
            break;
        case 1:
            Robot::lidar->readLidar();
            mgb_state = 2;
            break;

        case 2:
            // Check to see if the lidar scan is complete
            if (Robot::lidar->readComplete() == true) {
                mgb_state = 3;
            }
            break;

        case 3:
            // Call the lidar code to find a cargo ball
            mgb_polarBallPt = Robot::lidar->findCargo();

            // Check if we got anything back
            if (mgb_polarBallPt.angle == 0.0 && mgb_polarBallPt.dist == 0) {
                // TODO: should this do another lidar scan or finish?
                mgb_scanCnt++;
                mgb_state = 1;//restart scan;
                if(mgb_scanCnt > 10)
                    mgb_state = 7;
            }
            else {
                    mgb_state = 4;
            }
            break;

        case 4:  {
            // We have a ball within range of the arm - move the waist and arm to position over the ball
            const int  k_WaistDistance(183);   // distance between the waist and the lidar

            // Need to make the distance and angle relative to the center of the waist
            const double  lidar_dist = static_cast<double>(mgb_polarBallPt.dist);
            const double  lidar_angle = mgb_polarBallPt.angle;

            // calculate the distance from the waist to the ball (using cosine law)
            const double  waist_distance = sqrt(lidar_dist * lidar_dist + k_WaistDistance * k_WaistDistance - 
                                            2 * lidar_dist * k_WaistDistance * cos(lidar_angle * M_PI / 180.0));

            // calculate the angle from the waist to the ball (using sine law)
            const double waist_angle = asin(lidar_dist * sin(lidar_angle * M_PI / 180.0) / lidar_dist) / M_PI * 180.0;

            // Convert to cartesean coordinates for the arm
            const double  radians = M_PI * waist_angle / 180;

            mgb_cartX = std::round(waist_distance * std::cos(radians));
            mgb_cartY = -(std::round(waist_distance * std::sin(radians)));
            mgb_angle = waist_angle;
            mgb_cartX = mgb_cartX * 0.0393701;//in mm convert to inchs
            double ang = asin((mgb_cartX * sin(radians))/(20)) * 180/M_PI;
            printf("Langle=%f | Wangle = %f | Ldist = %f | Wdist = %f | x=%f | y=%f",lidar_angle,mgb_angle,lidar_dist,waist_distance,mgb_cartX,(ang + mgb_angle) / 2);

            if(mgb_cartX > 34){ //Outside 30"
                return true;
            }

            Robot::manipulatorArm->moveWaist(mgb_angle);

            mgb_state = 5;
            mgb_wrist = -80.0;
            mgb_delayState = 0;
            if(mgb_angle < 15)
                mgb_state = 6;
            
            if(mgb_cartX < 20){
                mgb_state = 6;
                mgb_delayState = 1;
                mgb_Move1 = false;
            }
                
            gb_cnt = 0;
            break;
        }
        case 5:
            if(mgb_delayState == 0) {
                if(gb_cnt > 20)
                    mgb_state = 6;
                gb_cnt++;
            }
            else if(mgb_delayState == 1){
                mgb_Move1 = Robot::manipulatorArm->moveToXY(mgb_cartX,27.5,-80,mgb_angle,35.0);
                if(mgb_Move1)
                    mgb_state = 6;
            }
            break;
        case 6:
            //Move the arm and the waist to pickup the ball
            mgb_Move2 = Robot::manipulatorArm->moveToXY(mgb_cartX,18,mgb_wrist,mgb_angle,35.0); // Move to X,Y co-ords
            Robot::manipulatorArm->intakeWheelsSpin(-0.7);
            if(mgb_Move2 && Robot::manipulatorArm->ifCargo())
                mgb_state = 7;
            break;

        case 7:
            Robot::manipulatorArm->intakeWheelsSpin(0.0);
            Robot::manipulatorArm->m_CurrentPosition = 0;
            mgb_Move3 = Robot::manipulatorArm->moveToXY(7.0,26.0,-10.0,0,35.0);
            if(mgb_Move3){
                mgb_state = 0;
                return true;
            }
            break;
    }
    return false;
}