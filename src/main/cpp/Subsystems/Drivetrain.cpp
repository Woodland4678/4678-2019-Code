// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "../../include/Subsystems/Drivetrain.h"
#include "../../include/Commands/DriveRobot.h"
#include "rev/CANSparkMax.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../../include/Commands/RobotDrive.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Drivetrain::Drivetrain() : frc::Subsystem("Drivetrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftMaster.reset(new rev::CANSparkMax(13, rev::CANSparkMax::MotorType::kBrushless));
    leftSlaveOne.reset(new rev::CANSparkMax(1, rev::CANSparkMax::MotorType::kBrushless));
    leftSlaveTwo.reset(new rev::CANSparkMax(2, rev::CANSparkMax::MotorType::kBrushless));
    rightMaster.reset(new rev::CANSparkMax(3, rev::CANSparkMax::MotorType::kBrushless));
    rightSlaveOne.reset(new rev::CANSparkMax(4, rev::CANSparkMax::MotorType::kBrushless));
    rightSlaveTwo.reset(new rev::CANSparkMax(5, rev::CANSparkMax::MotorType::kBrushless));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void Drivetrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new DriveRobot());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Drivetrain::Periodic() {
    // Put code here to be run every loop

}

void Drivetrain::configMotors(){
    leftSlaveOne->Follow(*leftMaster);
    leftSlaveOne->SetSmartCurrentLimit(40,40,40);
    leftSlaveTwo->Follow(*leftMaster);
    leftSlaveTwo->SetSmartCurrentLimit(40,40,40);
    rightSlaveOne->Follow(*rightMaster);
    rightSlaveOne->SetSmartCurrentLimit(40,40,40);
    rightSlaveTwo->Follow(*rightMaster);
    rightSlaveTwo->SetSmartCurrentLimit(40,40,40);
    rightMaster->SetSmartCurrentLimit(40,40,40);
    leftMaster->SetSmartCurrentLimit(40,40,40);
}

void Drivetrain::setLeftMotor(double power){
    leftMaster->Set(power);
}

void Drivetrain::setRightMotor(double power){
    rightMaster->Set(-power);
}

//void Drivetrain::test(double power){
   // rightSlaveTwo->Set(power);
//}

double Drivetrain::getLeftEncoder(){
   return leftMaster->GetEncoder().GetPosition();

}

double Drivetrain::getRightEncoder(){
    return rightMaster->GetEncoder().GetPosition();
}

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

void Drivetrain::joystickDriveCalculator() {

    double joyX = Robot::oi->getdriver()->GetX();
    double joyY = Robot::oi->getdriver()->GetY();
    double radiusSquared = joyX*joyX + joyY*joyY;
    double joyV = joyY - joyX;                      // used in calculating the motor power
    double joyW = joyY + joyX;                      // used in calculating the motor power

    double leftPower = 0.0;
    double rightPower = 0.0;

    int quadrant = 0;

    // Check deadzone
    if (radiusSquared > deadzone) {
        setLeftMotor(0);
        setRightMotor(0);
        return;
    }

    // check quadrant
    if (joyY >= 0.0) {
        if (joyX >= 0.0)   
            quadrant = 1;
        else
            quadrant = 2;
    } else {
        if (joyX < 0.0)
            quadrant = 3;
        else
            quadrant = 4;
    }
    
    switch (quadrant) {

        // quadrant 1
        case 1:

            // in this quadrant the left motor will always be going forwards, scaled back depending on how far the joystick is from its centre
            setLeftMotor( (radiusSquared - deadzone) / (1.0 - deadzone) );

            setRightMotor( (((k + 1)*(joyV + 1) - k) / (k + joyV + 1)) * ((radiusSquared - deadzone) / (1.0 - deadzone)) );

            break;

        // quadrant 2
        case 2:

            setRightMotor( (radiusSquared - deadzone) / (1.0 - deadzone) );

            setLeftMotor( (((k + 1)*(joyW + 1) - k) / (k + joyW + 1)) * ((radiusSquared - deadzone) / (1.0 - deadzone)) );

            break;
        
        // quadrant 3
        case 3:

            setLeftMotor( -(radiusSquared - deadzone) / (1.0 - deadzone) );

            setRightMotor( (((k + 1)*(joyV + 1) - k) / (k + joyV + 1)) * ((radiusSquared - deadzone) / (1.0 - deadzone)) );

            break;
        
        // quadrant 4
        case 4:

            setRightMotor( -(radiusSquared - deadzone) / (1.0 - deadzone) );

            setLeftMotor( (((k + 1)*(joyW + 1) - k) / (k + joyW + 1)) * ((radiusSquared - deadzone) / (1.0 - deadzone)) );

            break;
    }


}