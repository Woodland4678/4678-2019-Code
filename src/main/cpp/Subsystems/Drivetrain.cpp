// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "../../include/Subsystems/Drivetrain.h"
#include "../../include/Commands/DriveRobot.h"
#include "../../include/Commands/RobotDrive.h"
#include "rev/CANSparkMax.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Drivetrain::Drivetrain() : frc::Subsystem("Drivetrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftMaster.reset(new rev::CANSparkMax(13, rev::CANSparkMax::MotorType::kBrushless));
    leftSlaveOne.reset(new rev::CANSparkMax(1, rev::CANSparkMax::MotorType::kBrushless));
    leftSlaveTwo.reset(new rev::CANSparkMax(2, rev::CANSparkMax::MotorType::kBrushless));
    rightMaster.reset(new rev::CANSparkMax(3, rev::CANSparkMax::MotorType::kBrushless));
    rightSlaveOne.reset(new rev::CANSparkMax(4, rev::CANSparkMax::MotorType::kBrushless));
    rightSlaveTwo.reset(new rev::CANSparkMax(5, rev::CANSparkMax::MotorType::kBrushless));
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
}

void Drivetrain::InitDefaultCommand() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    SetDefaultCommand(new DriveRobot());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

void Drivetrain::Periodic() {}

void Drivetrain::configMotors() {
    leftSlaveOne->Follow(*leftMaster);
    leftSlaveOne->SetSmartCurrentLimit(40,40,40);
    leftSlaveTwo->Follow(*leftMaster);
    leftSlaveTwo->SetSmartCurrentLimit(40,40,40);
    rightSlaveOne->Follow(*rightMaster);
    rightSlaveOne->SetSmartCurrentLimit(40,40,40);
    rightSlaveTwo->Follow(*rightMaster);
    rightSlaveTwo->SetSmartCurrentLimit(40,40,40);
    rightMaster->SetSmartCurrentLimit(40,40,40);
    leftMaster->SetSmartCurrentLimit(40,40,40);
}

void Drivetrain::setLeftMotor(double power) {
    leftMaster->Set(power);
}

void Drivetrain::setRightMotor(double power) {
    rightMaster->Set(-power);
}

//void Drivetrain::test(double power){
   // rightSlaveTwo->Set(power);
//}

double Drivetrain::getLeftEncoder() {
   return leftMaster->GetEncoder().GetPosition();
}

double Drivetrain::getRightEncoder() {
    return rightMaster->GetEncoder().GetPosition();
}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

void Drivetrain::joystickDriveCalculator() {


    // declare motor power and quadrant varialbes
    double leftPower;
    double rightPower;
    int quadrant;

    // get joystick values
    double joyX = Robot::oi->getdriver()->GetX();
    double joyY = -Robot::oi->getdriver()->GetY();

    // calculate radius squared (used in testing for deadzone and in scalling based on the radius)
    double radiusSquared = joyX*joyX + joyY*joyY;

    // used later to store joyV and drive algoritm function output
    double joyV;

    // used in calculating the motor power (adjusts power based on joystick's distance from centre)
    double radiusScaler = (radiusSquared - deadRadiusSquared) / (1.0 - deadRadiusSquared);


    // Check deadzone
    if (radiusSquared <= deadRadiusSquared) {
        setLeftMotor(0);
        setRightMotor(0);
        //frc::SmartDashboard::PutBoolean("deadzone active:", true);
        return;
    }
    //frc::SmartDashboard::PutBoolean("deadzone active:", false);


    // check quadrant and calculate Z
    if (joyY >= 0.0) {

        // quadrant 1
        if (joyX >= 0.0) {
            quadrant = 1;
            joyV = joyY - joyX;
        }

        // quadrant 2
        else {
            quadrant = 2;
            joyV = joyY + joyX;
        }

    } else {

        // quadrant 3
        if (joyX < 0.0) {
            quadrant = 3;
            joyV = -joyY + joyX;
        }

        // quadrant 4
        else {
            quadrant = 4;
            joyV = -joyY - joyX;
        }
    }
    //frc::SmartDashboard::PutNumber("joyV:", joyV);


    // adjusting joyV to reduce sensitivity (using rational function), this is the core math of the algorithm
    joyV = ((turningFxnCoefficient + 1)*(joyV + 1) - turningFxnCoefficient) / (turningFxnCoefficient + joyV + 1) * radiusScaler;


    // set motor power varialbes based on quadrant
    switch (quadrant) {

        // quadrant 1
        case 1:
            leftPower = radiusScaler;
            rightPower = joyV;
            break;

        // quadrant 2
        case 2:
            leftPower = joyV;
            rightPower = radiusScaler;
            break;
        
        // quadrant 3
        case 3:
            leftPower = -radiusScaler;
            rightPower = joyV;
            break;
        
        // quadrant 4
        case 4:
            leftPower = joyV;
            rightPower = -radiusScaler;
            break;
    }


    // PutNumber() debug statements
    //frc::SmartDashboard::PutNumber("turning function coefficient:", turningFxnCoefficient);

    frc::SmartDashboard::PutNumber("x:", joyX);
    frc::SmartDashboard::PutNumber("y:", joyY);

    frc::SmartDashboard::PutNumber("quadrant:", quadrant);

    frc::SmartDashboard::PutNumber("radius squared:", radiusSquared);
    frc::SmartDashboard::PutNumber("deadzone squared:", deadRadiusSquared);

    frc::SmartDashboard::PutNumber("radius scaler:", radiusScaler);
    frc::SmartDashboard::PutNumber("drive function output:", joyV);

    frc::SmartDashboard::PutNumber("left motor power:", leftPower);
    frc::SmartDashboard::PutNumber("right motor power:", rightPower);
    

    // set motor power
    //setLeftMotor(leftPower);
    //setRightMotor(rightPower);
}