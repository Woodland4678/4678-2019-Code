
// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Commands/AutonomousCommand.h"
#include "Robot.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutonomousCommand::AutonomousCommand(): frc::Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::drivetrain.get());
	Requires(Robot::manipulatorArm.get());
}
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void AutonomousCommand::Initialize() { //back up and turn to 10.4 degrees
    initialGyroValue = Robot::ahrs->GetAngle();
	//autoSide 1 = left, 2 = center, 3 = right
	if (Robot::oi->getAutoSwitch()->GetRawButton(14)) {
		autoSide += 1;
	}
	if (Robot::oi->getAutoSwitch()->GetRawButton(15)) {
		autoSide += 2;
	}
    if (Robot::oi->getAutoSwitch()->GetRawButton(16)) {
		autoSide += 4;
	}

    // switch 2 determines the objective during autonomous
    // see AutoScenarioHelpers.cpp  transformConsoleSwitch2 - values there must match below
	//autoMode 1 = single hatch level 1 hab, 2 = single hatch level 2 hab
	if (Robot::oi->getAutoSwitch()->GetRawButton(13)) {
		autoMode += 1;
	}
	if (Robot::oi->getAutoSwitch()->GetRawButton(12)) {
		autoMode += 2;
	}
	if (Robot::oi->getAutoSwitch()->GetRawButton(11)) {
		autoMode += 4;
	}
	Robot::drivetrain->resetGoToDistanceState();
	autoState = 0;
	autoStateSecondHatch = 0;
	Robot::drivetrain->setToBrake();
	armMovement1 = false;
	if (autoSide == 0 && autoMode == 1) { //Left side, level 1 auto to cargo ship
		leftCmStraightBack = -130;
		rightCmStraightBack = -130;

		leftArc = -405;
		rightArc = -360;

		straightBackRampUpDistance = 100;

		amountToTurn = -90 + initialGyroValue;
	} else if (autoSide == 0 && autoMode == 2) { //left Side level 2 auto to cargo ship
		leftCmStraightBack = -220;
		rightCmStraightBack = -220;

		straightBackRampUpDistance = 125;
		leftArc = -405;
		rightArc = -360;
		amountToTurn = -89;
	}

	else if (autoSide == 1 && autoMode == 1) { //Right Side level 1 auto to cargo ship
		leftCmStraightBack = -150;
		rightCmStraightBack = -150;

		straightBackRampUpDistance = 100;
		amountToTurn = -12 + initialGyroValue;
	} else if (autoSide == 1 && autoMode == 2) { //right side level 2 auto to cargo ship
		leftCmStraightBack = -220;
		rightCmStraightBack = -220;
		straightBackRampUpDistance = 125;
		leftArc = -347;
		rightArc = -392;
		amountToTurn = 90;
	} else { //any other mode finish auto mode (not sure if this goes to teleop control or not)
		End();
		done = true;
	}
	
	
}

// Called repeatedly when this Command is scheduled to run
void AutonomousCommand::Execute() {
	printf("RUNNING AUTO");
	switch(autoState) {
		case 0: //gets off the HAB
		if (!armMovement0) {
			armMovement0 = Robot::manipulatorArm->moveToXY(5,19,-248,0,20.0);
		}
			
			
			if (Robot::drivetrain->goToDistance(rightCmStraightBack, leftCmStraightBack,0.35,straightBackRampUpDistance,30,0.15,0.3)) { //-69, //-315, -315 //-435,-435
				autoState++;
				Robot::manipulatorArm->m_CurrentPosition = 0;
				Robot::drivetrain->resetGoToDistanceState();
				cnt = 0;
			}

		break;
		case 1: //arcs to the cargo ship side
			if (!armMovement0) {
				armMovement0 = Robot::manipulatorArm->moveToXY(5,19,-248,0,20.0);
			}
			if (Robot::drivetrain->goToDistance(rightArc, leftArc,0.65,100,50,0.3,0.4)) {
				autoState++;
				Robot::manipulatorArm->m_CurrentPosition = 0;
				Robot::drivetrain->resetGoToDistanceState();
				cnt = 0;
			}

		break;
		case 2: //brief pause after arc
			cnt++;
			if (cnt > 10) {
				autoState++;
				cnt = 0;
			}
		break;
		case 3: //gyro turn toward the cargo ship
			if (!armMovement1) {
				armMovement1 = Robot::manipulatorArm->moveToXY(25.5,21,-190.0,0,20.0);
			}
			
			if (Robot::drivetrain->GyroTurn(Robot::ahrs->GetAngle(), amountToTurn + initialGyroValue, 0.015,0,0)) {
				autoState++;
				cnt = 0;
			} 
		break;
		case 4: //small pause after gyro turn
			// cnt++;
			// if (cnt > 10) {
			// 	//autoState++;
			// }
			if (driverControl()) {
				autoState++;
			}
		break;
		case 5:
			if (getSecondHatch()) {
				autoState++;
			}
		break;
		case 6:
			done = true;
			End();
		break;
		case 7:

		break;
		case 8:

		break;
		case 9:
			
		break;
		case 10:
		break;
	}

	if (Robot::oi->getdriver()->GetRawButton(9)) { //Override to allow drivers to take control
		done = true;
		End();
	}
}

// Make this return true when this Command no longer needs to run execute()
bool AutonomousCommand::getSecondHatch() {
	switch(autoStateSecondHatch) {
		case 0:
			if (!armMovement1) {
				armMovement1 = Robot::manipulatorArm->moveToXY(25.5,21,-190.0,0,20.0);
			} else {
				autoStateSecondHatch++;
				cnt = 0;
			}
		break;
		case 1:
			cnt++;
			Robot::manipulatorArm->releaseHatch();
			if (cnt > 50) {
				if (Robot::drivetrain->goToDistance(-50,-50,0.35,20,30,0.2,0.15)) {
					autoStateSecondHatch++;
					cnt = 0;
				}
			}
		break;
		case 2:
			if (!armMovement2) {
				armMovement2 = Robot::manipulatorArm->moveToXY(7.0,26.0,-190,0,20.0);
			} else {
				autoStateSecondHatch++;
			}
			Robot::manipulatorArm->grabHatch();
			// cnt++;
			// if (cnt > 10) {
			// 	autoState++;
			// }
		break;
		case 3:
			// if (!armMovement2) {
			// 	armMovement2 = Robot::manipulatorArm->moveToXY(7.0,26.0,-190,0,20.0);
			// }
			Robot::manipulatorArm->grabHatch();
			if (Robot::drivetrain->GyroTurn(Robot::ahrs->GetAngle(), 8.5, 0.012, 0,0)) {
				autoStateSecondHatch++;
				cnt = 0;
			}
		break;
		case 4:
			if (!armMovement2) {
				armMovement2 = Robot::manipulatorArm->moveToXY(7.0,26.0,-190,0,20.0);
			}
			cnt++;
			if (cnt > 10) {
				autoStateSecondHatch++;
			}

		break;
		case 5:
			if (!armMovement2) {
				armMovement2 = Robot::manipulatorArm->moveToXY(7.0,26.0,-190,0,20.0);
			}
			if (Robot::drivetrain->goToDistance(420,420,0.7,70,70,0.2,0.2)) {
				autoStateSecondHatch++;
			}
		break;
		case 6:
			return true;
		break;

	}
	return false;
}

bool AutonomousCommand::driverControl() {
	double JoyX = Robot::oi->getdriver()->GetX();
    double JoyY = Robot::oi->getdriver()->GetY();
    //frc::SmartDashboard::PutNumber("Current Angle: ", Robot::ahrs->GetAngle());
    // Get X and Y values with some deadband.  Subtract/add deadband back in to ensure we
    // start at 0.0 instead of +/-0.05
    if ((JoyX > -0.05)&&(JoyX <= 0.05))
        JoyX = 0.0;
    else if (JoyX < -0.05)
        JoyX += 0.05;
    else
        JoyX -= 0.05;

    if ((JoyY > -0.05)&&(JoyY <= 0.05)) {
        JoyY = 0.0;
        if(Robot::manipulatorArm->m_FineLimitHit)
            JoyY = -0.2;
    }
    else if (JoyY < -0.05)
        JoyY += 0.05;
    else
        JoyY -= 0.05;

    // Use X^2
    double JoyX2 = JoyX * JoyX;
    double JoyY2 = JoyY * JoyY;

    // Correct the sign since x^2 is always positive.
    if (JoyX < 0)
        JoyX2 =-JoyX2;
    if (JoyY < 0)
        JoyY2 = -JoyY2;

    // Calculate Power Value.
    // Multiplier last year was 0.75, but too sensitive this year. 
    // March 9 11:00 am Start for drivers at 0.35 and adjust

    // This may make turning kinda slow.  We should really read
    // current speed and adjust the amount of JoyX2 based on 
    // the speed reading.
    double leftPower = -(JoyY2 - 0.35 * JoyX2);   
    double rightPower = -(JoyY2 + 0.35 * JoyX2);

    //frc::SmartDashboard::PutNumber("left Power: ", leftPower);
   // frc::SmartDashboard::PutNumber("right Power: ", rightPower);

   

    if(!Robot::climber->m_Climbing) {
        if (Robot::oi->getdriver()->GetRawButton(6)) {
            leftPower *= 0.30;
            rightPower *= 0.30;
        }
        Robot::drivetrain->setLeftMotor(leftPower);
        Robot::drivetrain->setRightMotor(rightPower);
    }
    // Steve test ****

    // Deadzone.
    if (fabs(JoyX) < 0.05 && fabs(JoyY) < 0.05)
        JoyX = 0.0;
    else if (JoyX > 0)
        JoyX -= 0.05;
    else
        JoyX += 0.05;

    if (fabs(JoyY) < 0.05)
        JoyY = 0.0;
    else if (JoyY > 0)
        JoyY -= 0.05;
    else
        JoyY += 0.05;

	if (Robot::oi->getoperator1()->GetRawButton(12)) { //move on to next part when operator presses right joystick
		return true;
	} else {
		return false;
	}
}

bool AutonomousCommand::IsFinished() {
    return done;
}

// Called once after isFinished returns true
void AutonomousCommand::End() {
	Robot::drivetrain->setLeftMotor(0);
	Robot::drivetrain->setRightMotor(0);
	Robot::drivetrain->setToCoast();
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AutonomousCommand::Interrupted() {
	Robot::drivetrain->setLeftMotor(0);
	Robot::drivetrain->setRightMotor(0);
	Robot::drivetrain->setToCoast();
}


