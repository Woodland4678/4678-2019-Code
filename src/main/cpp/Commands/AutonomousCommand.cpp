// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Commands/AutonomousCommand.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutonomousCommand::AutonomousCommand(): frc::Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::drivetrain.get());
	Requires(Robot::manipulatorArm.get());
}
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void AutonomousCommand::Initialize() { //back up and turn to 10.4 degrees
    initialGyroValue = Robot::ahrs->GetAngle();
	if (Robot::oi->getAutoSwitch()->GetRawButton(14)) {
		autoSide += 1;
	}
	if (Robot::oi->getAutoSwitch()->GetRawButton(15)) {
		autoSide += 2;
	}
    if (Robot::oi->getAutoSwitch()->GetRawButton(16)) {
		autoSide += 4;
	}

    // switch 2 determines the objective during autonomous
    // see AutoScenarioHelpers.cpp  transformConsoleSwitch2 - values there must match below

	if (Robot::oi->getAutoSwitch()->GetRawButton(13)) {
		autoMode += 1;
	}
	if (Robot::oi->getAutoSwitch()->GetRawButton(12)) {
		autoMode += 2;
	}
	if (Robot::oi->getAutoSwitch()->GetRawButton(11)) {
		autoMode += 4;
	}
	Robot::drivetrain->resetGoToDistanceState();
	autoState = 0;
	Robot::drivetrain->setToBrake();
	armMovment1 = false;
	if (autoSide == 0 && autoMode == 1) { //Left side, level 1 auto to cargo ship
		leftCmStraightBack = -340;
		rightCmStraightBack = - 340;

		rightCmArcToCargoShip = -140;
		leftCmArcToCargoShip = -268;
		straightBackRampUpDistance = 270;

		amountToTurn = 12 + initialGyroValue;
	} else if (autoSide == 0 && autoMode == 2) { //left Side level 2 auto to cargo ship
		leftCmStraightBack = -435;
		rightCmStraightBack = - 435;

		rightCmArcToCargoShip = -140;
		leftCmArcToCargoShip = -268;

		straightBackRampUpDistance = 270;
		amountToTurn = 12 + initialGyroValue;
	}

	else if (autoSide == 2 && autoMode == 1) { //Right Side level 1 auto to cargo ship
		leftCmStraightBack = -340;
		rightCmStraightBack = - 340;

		rightCmArcToCargoShip = -268;
		leftCmArcToCargoShip = -140;
		straightBackRampUpDistance = 270;
		amountToTurn = -12 + initialGyroValue;
	} else if (autoSide == 2 && autoMode == 2) { //right side level 2 auto to cargo ship
		leftCmStraightBack = -435;
		rightCmStraightBack = - 435;

		rightCmArcToCargoShip = -268;
		leftCmArcToCargoShip = -140;

		straightBackRampUpDistance = 270;
		amountToTurn = -12 + initialGyroValue;
	}
}

// Called repeatedly when this Command is scheduled to run
void AutonomousCommand::Execute() {
	frc::SmartDashboard::PutNumber("Current Angle: ", Robot::ahrs->GetAngle());
	//printf("AUTONOMOUS STATE: %f", autoState);
	switch(autoState) {
		case 0:
		//printf("RUNNING STATE 0");
			//if (Robot::drivetrain->goToDistance(493,493,0.9,150,150,0.1,0.1)) {
			//printf("Go To distance Percent complete: %f", Robot::drivetrain->percentDone());
			if (Robot::drivetrain->goToDistance(rightCmStraightBack, leftCmStraightBack,0.9,straightBackRampUpDistance,150,0.1,0.4)) { //-69, //-315, -315 //-435,-435
				autoState = 2;
				Robot::manipulatorArm->m_CurrentPosition = 0;
				Robot::drivetrain->resetGoToDistanceState();
			}
		break;
		case 1:
			// if (Robot::manipulatorArm->moveToXY(25.5,21,-190.0,0,20.0)) {
			// 	autoState++;
			// }
			// cnt++;
			// if (cnt > 10) {
			// 	autoState++;
			// 	cnt = 0;
			// 	Robot::drivetrain->resetGoToDistanceState();
			// }

		break;
		case 2:
			//if ((Robot::drivetrain->GyroTurn(Robot::ahrs->GetAngle(), 93, 0.01, 0, 0))) {
			if (!armMovment1) {
				armMovment1 = Robot::manipulatorArm->moveToXY(25.5,21,-190.0,0,20.0);
			}
			if (Robot::drivetrain->goToDistance(rightCmArcToCargoShip, leftCmArcToCargoShip,0.4,0,50,0.4,0.4)) { //-164,-248
				autoState++;
				//Robot::drivetrain->setRightMotor(0);
				//Robot::drivetrain->setLeftMotor(0);
				Robot::drivetrain->resetGoToDistanceState();
			} 
		break;
		case 3:
			if (!armMovment1) {
				armMovment1 = Robot::manipulatorArm->moveToXY(25.5,21,-190.0,0,20.0);
			}
			cnt++;
			if (cnt > 25) {
				autoState++;
				cnt = 0;
			}

		break;
		case 4:
			// if (!armMovment1) {
			// 	armMovment1 = Robot::manipulatorArm->moveToXY(25.5,21,-190.0,0,20.0);
			// }
			// Robot::drivetrain->setToCoast();
			if (!armMovement2) {
				armMovement2 = Robot::manipulatorArm->moveToXY(7.0,26.0,-190,0,20.0);
			}
			if (Robot::drivetrain->GyroTurn(Robot::ahrs->GetAngle(), amountToTurn, 0.015, 0, 0)) {
				autoState++;
			}
			// if (Robot::drivetrain->goToDistance(50,50,0.3,20,20,0.1,0.1)) {
			// 	autoState++;
			// 	Robot::drivetrain->setRightMotor(0);
			// 	Robot::drivetrain->setLeftMotor(0);
			// }
		break;
		case 5:
			cnt++;
			if (!armMovement2) {
				armMovement2 = Robot::manipulatorArm->moveToXY(7.0,26.0,-190,0,20.0);
			}
			if (cnt > 15) {
				autoState++;
			}
		break;
		case 6:
			// if (!armMovement2) {
			// 	armMovement2 = Robot::manipulatorArm->moveToXY(7.0,26.0,-190,0,20.0);
			// }
			if (Robot::drivetrain->percentDone() > 0.6) {
				if (!armMovement3) {
					armMovement3 = Robot::manipulatorArm->moveToXY(28.5,21.0,-190.0,0,20.0);
				}
			}
			if (Robot::drivetrain->goToDistance(430, 430, 0.6,150,150,0.2,0.4)) {
				autoState++;
				Robot::manipulatorArm->m_CurrentPosition = 5;
			}
		break;
		case 7:
			if (!armMovement3) {
				armMovement3 = Robot::manipulatorArm->moveToXY(28.5,21.0,-190.0,0,20.0);
			} else {
				autoState++;
			}
		break;
		case 8:
			
		break;
		case 9:
			
		break;
	}
}

// Make this return true when this Command no longer needs to run execute()
bool AutonomousCommand::IsFinished() {
    return false;
}

// Called once after isFinished returns true
void AutonomousCommand::End() {
	Robot::drivetrain->setLeftMotor(0);
	Robot::drivetrain->setRightMotor(0);
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AutonomousCommand::Interrupted() {

}
