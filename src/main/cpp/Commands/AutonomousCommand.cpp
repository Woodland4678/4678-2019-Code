
// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Commands/AutonomousCommand.h"
#include "Robot.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

AutonomousCommand::AutonomousCommand(): frc::Command() {
        // Use requires() here to declare subsystem dependencies
    // eg. requires(Robot::chassis.get());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::drivetrain.get());
	Requires(Robot::manipulatorArm.get());
}
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR

// Called just before this Command runs the first time
void AutonomousCommand::Initialize() { //back up and turn to 10.4 degrees
    initialGyroValue = Robot::ahrs->GetAngle();
	//autoSide 1 = left, 2 = center, 3 = right
	if (Robot::oi->getAutoSwitch()->GetRawButton(14)) {
		autoSide += 1;
	}
	if (Robot::oi->getAutoSwitch()->GetRawButton(15)) {
		autoSide += 2;
	}
    if (Robot::oi->getAutoSwitch()->GetRawButton(16)) {
		autoSide += 4;
	}

    // switch 2 determines the objective during autonomous
    // see AutoScenarioHelpers.cpp  transformConsoleSwitch2 - values there must match below
	//autoMode 1 = single hatch level 1 hab, 2 = single hatch level 2 hab
	if (Robot::oi->getAutoSwitch()->GetRawButton(13)) {
		autoMode += 1;
	}
	if (Robot::oi->getAutoSwitch()->GetRawButton(12)) {
		autoMode += 2;
	}
	if (Robot::oi->getAutoSwitch()->GetRawButton(11)) {
		autoMode += 4;
	}
	Robot::drivetrain->resetGoToDistanceState();
	autoState = 0;
	autoStateSecondHatch = 0;
	Robot::drivetrain->setToBrake();
	armMovement1 = false;
	if (autoSide == 0 && autoMode == 1) { //Left side, level 1 auto to cargo ship
		autonomousSelection = 1;

		leftCmStraightBack = -135;
		rightCmStraightBack = -135;

		leftArc = -380;
		rightArc = -315;

		straightBackRampUpDistance = 30;

		amountToTurn = -88 + initialGyroValue;
		secondHatchAmountToTurn = 10 + initialGyroValue;
	} else if (autoSide == 0 && autoMode == 2) { //left Side level 2 auto to cargo ship
		autonomousSelection = 2;
		leftCmStraightBack = -200;
		rightCmStraightBack = -200;

		straightBackRampUpDistance = 125;
		leftArc = -380;
		rightArc = -315;
		amountToTurn = -89 + initialGyroValue;
		secondHatchAmountToTurn = 10 + initialGyroValue;
	}

	else if (autoSide == 2 && autoMode == 1) { //Right Side level 1 auto to cargo ship
		autonomousSelection = 3;
		leftCmStraightBack = -135;
		rightCmStraightBack = -135;
		leftArc = -285;
		rightArc = -310;
		straightBackRampUpDistance = 40;
		amountToTurn = 88 + initialGyroValue;
		secondHatchAmountToTurn = -7 + initialGyroValue;
	} else if (autoSide == 2 && autoMode == 2) { //right side level 2 auto to cargo ship
		autonomousSelection = 4;
		leftCmStraightBack = -205;
		rightCmStraightBack = -205;
		straightBackRampUpDistance = 125;
		leftArc = -320;
		rightArc = -360;
		amountToTurn = 88 + initialGyroValue;
		secondHatchAmountToTurn = -10 + initialGyroValue;
	} else if (autoSide == 2 && autoMode == 3) { // right side far Rocket hatch low
		autonomousSelection = 5;
		rightArc = -495;
		leftArc = -430;
		amountToTurn = -38;
	} else if (autoSide == 0 && autoMode == 3) { //left side far Rocket hatch low
		autonomousSelection = 5;
		rightArc = -450;
		leftArc = -535;
		amountToTurn = 38;
	}
	
	else { //any other mode finish auto mode goes to full driver control
		End();
		done = true;
	}
}

// Called repeatedly when this Command is scheduled to run
void AutonomousCommand::Execute() {
	switch(autonomousSelection) {
		case 0:
			scoreFirstHatch();
		break;
		case 1:
			scoreFirstHatch();
		break;
		case 2:
			scoreFirstHatch();
		break;
		case 3:
			scoreFirstHatch();
		break;
		case 4:
			scoreFirstHatch();
		break;
		case 5:
			scoreFarRocket();
		break;
	}

	if (Robot::oi->getdriver()->GetPOV() == 270) { //Override to allow drivers to take control
		done = true;
		End();
	}
}

// Make this return true when this Command no longer needs to run execute()
bool AutonomousCommand::scoreFirstHatch() {
	switch(autoState) {
		case 0: //gets off the HAB
		Robot::manipulatorArm->grabHatch();
		if (!armMovement0) {
			armMovement0 = Robot::manipulatorArm->moveToXY(8,21,-230,0,30);
		}
			if (Robot::drivetrain->goToDistance(rightCmStraightBack, leftCmStraightBack,0.35,straightBackRampUpDistance,30,0.15,0.3)) { //-69, //-315, -315 //-435,-435
				autoState++;
				Robot::manipulatorArm->m_CurrentPosition = 0;
				Robot::drivetrain->resetGoToDistanceState();
				cnt = 0;
			}

		break;
		case 1: //arcs to the cargo ship side
			if (!armMovement0) {
				armMovement0 = Robot::manipulatorArm->moveToXY(8,21,-230,0,30);
			}
			if (Robot::drivetrain->goToDistance(rightArc, leftArc,0.75,75,100,0.3,0.15)) {
				autoState++;
				Robot::manipulatorArm->m_CurrentPosition = 0;
				Robot::drivetrain->resetGoToDistanceState();
				cnt = 0;
			}

		break;
		case 2: //brief pause after arc
			cnt++;
			if (cnt > 15) {
				autoState++;
				cnt = 0;
			}
		break;
		case 3: //gyro turn toward the cargo ship
			if (!armMovement1) {
				armMovement1 = Robot::manipulatorArm->moveToXY(25.5,21.0,-182.0,0,30);
			}
			if ((Robot::drivetrain->GyroTurn(Robot::ahrs->GetAngle(), amountToTurn, 0.015,0,0)) && (armMovement1)) {
				autoState++;
				cnt = 0;
				Robot::drivetrain->initAutoScore();
			} 
		break;
		case 4: //Auto score the hatch panel
			// if (driverControl()) {
			// 	autoState++;
			// }

			//done = true;
			//End();
			autoScore = Robot::drivetrain->autoScore(0);
			if (autoScore == 1) {
				autoState++;
				armMovement2 = false;
			}
			else if (autoScore == 2 || autoScore == 3) {
				End();
				done = true;
			}
		break;
		case 5:
			//done = true;
			//End();
			 if (getSecondHatch()) {
			 	autoState++;
			 }
		break;
		case 6:
			done = true;
			End();
		break;
		case 7:

		break;
		case 8:

		break;
		case 9:
			
		break;
		case 10:
		break;
	}
}

bool AutonomousCommand::getSecondHatch() {
	switch(autoStateSecondHatch) {
		// case 0:
		// 	if (!armMovement1) {
		// 		armMovement1 = Robot::manipulatorArm->moveToXY(25.5,21,-190.0,0,20.0);
		// 	} else {
		// 		autoStateSecondHatch++;
		// 		cnt = 0;
		// 	}
		// break;
		case 0:

			if (Robot::drivetrain->goToDistance(-50,-50,0.35,20,30,0.2,0.15)) {
				autoStateSecondHatch++;
				cnt = 0;
			}
		break;
		case 1:
			if (!armMovement2) {
				armMovement2 = Robot::manipulatorArm->moveToXY(7.0,29,-203,0,30);
			} else {
				autoStateSecondHatch++;
			}
			Robot::manipulatorArm->grabHatch();
			// cnt++;
			// if (cnt > 10) {
			// 	autoState++;
			// }
		break;
		case 2:
			// if (!armMovement2) {
			// 	armMovement2 = Robot::manipulatorArm->moveToXY(7.0,26.0,-190,0,20.0);
			// }
			Robot::manipulatorArm->grabHatch();
			if (Robot::drivetrain->GyroTurn(Robot::ahrs->GetAngle(), secondHatchAmountToTurn, 0.012, 0,0)) {
				autoStateSecondHatch++;
				cnt = 0;
			}
		break;
		case 3:
			cnt++;
			if (cnt > 10) {
				autoStateSecondHatch++;
				cnt = 0;
			}

		break;
		case 4:
			if (Robot::drivetrain->goToDistance(455,455,0.8,70,90,0.2,0.2)) {
				autoStateSecondHatch++;
				autoScore = 0;
			}
		break;
		case 5:
			cnt++;
			if (cnt > 10) {
				autoScore = Robot::drivetrain->autoScore(0);
				if (autoScore == 1) {
					autoStateSecondHatch++;
					cnt = 0;
				}
				else if (autoScore == 2 || autoScore == 3) {
					cnt = 0;
					done = true;
					End();
				}
			}
		break;
		case 6:
			return true;
		break;

	}
	return false;
}

bool AutonomousCommand::scoreFarRocket() {
	switch(farRocketState) {
		case 0: //drives back off the level 2 platform
			Robot::manipulatorArm->grabHatch();
			if (!armMovement0) {
				armMovement0 = Robot::manipulatorArm->moveToXY(8,21,-230,0,30);
			}	
			if (Robot::drivetrain->goToDistance(-135, -135, 0.35, 50, 20, 0.15, 0.15)) {
				farRocketState++;
			}
		break;
		case 1: //arcs to the rocketship
			if (Robot::drivetrain->goToDistance(rightArc, leftArc, 0.7, 0, 120, 0.15,0.15)) {
				farRocketState++;
				cnt = 0;
			}
		break;
		case 2: //small delay after driving back
			if (cnt > 10) {
				if (Robot::drivetrain->GyroTurn(Robot::ahrs->GetAngle(), amountToTurn + initialGyroValue, 0.012,0,0)) {
					//farRocketState++;
					autoScore = 0;
				}
			} else {
				cnt++;
			}
		break;
		case 3: //auto score (this rocket is it's different than the cargo autoscore)
			autoScore = Robot::drivetrain->autoScore(1);
			if (autoScore == 1) {
				farRocketState++;
			} else if (autoScore == 2 || autoScore == 3) {
				done = true;
				End();
			}
		break;
		case 4: //will drive backwards a bit after scoring the hatch
			if (Robot::drivetrain->goToDistance(-50, -50, 0.35, 15, 15, 0.15, 0.15)) {
				farRocketState++;
			}
		break;
		case 5:
			done = true;
			End();
		break;

	}
}

bool AutonomousCommand::IsFinished() {
    return done;
}

// Called once after isFinished returns true
void AutonomousCommand::End() {
	Robot::drivetrain->setLeftMotor(0);
	Robot::drivetrain->setRightMotor(0);
	Robot::drivetrain->setToCoast();
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void AutonomousCommand::Interrupted() {
	Robot::drivetrain->setLeftMotor(0);
	Robot::drivetrain->setRightMotor(0);
	Robot::drivetrain->setToCoast();
}


